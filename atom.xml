<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lucky Dog&#39;s blogs</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-09-09T09:21:09.238Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>操作系统-进程管理（二）</title>
    <link href="http://example.com/post/ff4f3d52.html"/>
    <id>http://example.com/post/ff4f3d52.html</id>
    <published>2022-09-08T09:31:57.000Z</published>
    <updated>2022-09-09T09:21:09.238Z</updated>
    
    <content type="html"><![CDATA[<h1 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h1><p>当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要<strong>确定某种规则来决定处理这些任务的顺序</strong>，这就是“调度”研究的问题。</p><p>在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行。</p><h1 id="调度的三个层次"><a href="#调度的三个层次" class="headerlink" title="调度的三个层次"></a>调度的三个层次</h1><h2 id="高级调度-作业调度"><a href="#高级调度-作业调度" class="headerlink" title="高级调度(作业调度)"></a>高级调度(作业调度)</h2><p>在早期的多道批处理操作系统中，用户首先会通过外围机或者外围设备，将多道作业输入到磁盘或者硬盘的<strong>外存空间</strong>上，但是由于内存的地址空间是有限的，并不能将所有作业全部放在内存当中，会装不下，出现了<strong>资源不够的问题</strong>。</p><p>这种情况下，就需要<strong>调度</strong>来解决</p><img src="\image\article\操作系统-进程管理\image-20220908174809571.png" alt="image-20220908174809571" style="zoom:80%;" /><p>由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要<font color="red"><strong>确定某种规则</strong></font>来决定<font color="red"><strong>将作业调入内存的顺序</strong></font>。</p><p>​高级调度（作业调度）：按一定的原则从外存上处于后备队列的作业中挑选一个(或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB），以使它（们）获得竞争处理机的权利。</p><p>​高级调度是<strong>辅存（外存）与内存</strong>之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。</p><ul><li><strong>调入的时机</strong>需要<font color="red">操作系统</font>来确定</li><li><strong>调出的时机</strong>必然是<font color="red">作业运行结束</font>才调出。</li></ul><p>因此，<strong>高级调度</strong>主要是指<strong>调入的问题</strong></p><h2 id="中级调度（内存调度"><a href="#中级调度（内存调度" class="headerlink" title="中级调度（内存调度)"></a>中级调度（内存调度)</h2><p>引入了虚拟存储技术之后，可将<font color="red"><strong>暂时不能运行的进程</strong></font>调至<font color="blue"><strong>外存</strong></font>等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。<br>这么做的目的是为了<strong>提高内存利用率</strong>和<strong>系统吞吐量</strong>。</p><p><img src="/%5Cimage%5Carticle%5C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%5Cimage-20220908210050565.png" alt="image-20220908210050565"></p><p>暂时调到外存等待的进程状态为<font color="red"><strong>挂起状态</strong></font>。</p><p>值得注意的是：</p><ul><li><p><strong>PCB</strong>【进程控制块】<strong>并不会一起调到外存</strong>，而是会常驻内存。</p><p>PCB中会记录进程数据在外存中的存放位置，进程状态等信息。</p><p>操作系统还需要通过内存中的PCB来保持对各个进程的监控、管理。</p><p>被挂起的进程PCB会被放到的<font color="red"><strong>挂起队列</strong></font>中。</p></li><li><p><strong>进程的程序代码数据</strong>相关的会<strong>调到外存</strong>。</p></li></ul><blockquote><p>中级调度（内存调度)：就是要决定将<strong>哪个处于挂起状态的进程</strong>重新调入内存。</p></blockquote><h3 id="七状态模型"><a href="#七状态模型" class="headerlink" title="七状态模型"></a>七状态模型</h3><p>除了之前五种状态，与挂起有关的还有两个状态：</p><ul><li>阻塞挂起状态：进程<strong>在外存（硬盘）</strong>并等待某个事件的出现；</li><li>就绪挂起状态：进程<strong>在外存（硬盘）</strong>，但只要进入内存，即刻立刻运行；</li></ul><p><img src="/%5Cimage%5Carticle%5C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%5Cimage-20220908210529729.png" alt="image-20220908210529729"></p><p>导致进程挂起的原因不只是因为进程所使用的内存空间不在物理内存，还包括如下情况：</p><ul><li>通过 <strong>sleep 让进程间歇性挂起</strong>，其工作原理是设置一个定时器，到期后唤醒进程。</li><li><strong>用户希望挂起一个程序的执行</strong>，比如在 Linux 中用 <code>Ctrl+Z</code> 挂起进程；</li></ul><blockquote><p>挂起和阻塞的区别：</p><p>两种状态都是暂时不能获得CPU的服务</p><ul><li><p><strong>挂起态</strong>是将进程映像调到外存去了</p></li><li><p><strong>阻塞态</strong>下进程映像还在内存中。</p><p>有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为多个队列。</p></li></ul></blockquote><h2 id="低级调度（进程调度）"><a href="#低级调度（进程调度）" class="headerlink" title="低级调度（进程调度）"></a>低级调度（进程调度）</h2><p>进程调度是实现并发的基础。</p><p>低级调度（进程调度)，其主要任务是<font color="blue">按照某种方法和策略从就绪队列中选取一个进程，将<strong>处理机</strong>分配给它</font>。</p><p>进程调度是操作系统中<font color="red"><strong>最基本的一种调度</strong></font>，在一般的操作系统中都必须配置进程调度。</p><p>进程调度的频率很高，一般几十毫秒一次。</p><img src="\image\article\操作系统-进程管理\image-20220908211420064.png" alt="image-20220908211420064" style="zoom:80%;" /><h2 id="三层调度对比"><a href="#三层调度对比" class="headerlink" title="三层调度对比"></a>三层调度对比</h2><table><thead><tr><th></th><th>在谁之间进行调度</th><th>针对谁</th><th>发生频率</th><th>对进程状态影响</th></tr></thead><tbody><tr><td>高级调度</td><td>内存 和 外存【后备队列 –》 内存】</td><td>作业</td><td>最低</td><td>无–&gt;创建态–&gt;就绪态</td></tr><tr><td>中级调度</td><td>内存 和 外存【挂起队列 –》 内存】</td><td>进程</td><td>中等</td><td>挂起态 –&gt; 就绪态&#x2F;阻塞态</td></tr><tr><td>低级调度</td><td>内存  和  处理机CPU【就绪队列 –》 CPU】</td><td>进程</td><td>最高</td><td>就绪态 –&gt; 运行态</td></tr></tbody></table><h1 id="进程调度的时机"><a href="#进程调度的时机" class="headerlink" title="进程调度的时机"></a>进程调度的时机</h1><p>进程调度（低级调度)，就是<strong>按照某种算法从就绪队列中选择一个进程为其分配处理机。</strong></p><p>那什么时候需要进程调度呢？分为以下两种情况：</p><ul><li>当前运行的进程<font color="red"><strong>主动</strong></font>放弃处理机<ul><li>程序运行结束  或   程序因为异常终止【<strong>运行态 -&gt; 结束态</strong>】</li><li>进程主动请求进入阻塞（如：等等IO） 【<strong>运行态 -&gt; 阻塞态</strong>】</li></ul></li><li>当前运行的进程<font color="red"><strong>被动</strong></font>放弃处理机<ul><li>分给进程的时间片用完了</li><li>有更紧急的事需要处理（如 IO处理）</li><li>有更高优先级的进程进入队列。</li></ul></li></ul><p>不能进行调度和切换的情况：</p><ul><li>在<font color="blue"><strong>处理中断的过程中</strong></font>。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换。</li><li>进程在<font color="blue"><strong>操作系统内核程序临界区中</strong></font>。</li><li>在<font color="blue"><strong>原子操作过程中（原语）</strong></font>。原子操作不可中断，要一气呵成（如之前讲过的修改PCB中进程状态标志，并把PCB放到相应队列)</li></ul><blockquote><p><font color="green"><strong>什么是操作系统内核程序临界区？</strong></font></p><p><strong>临界资源</strong>：<strong>一次仅允许一个进程使用的资源</strong>，各进程需要<font color="red"><strong>互斥地</strong></font>访问临界资源。例如：物理设备中的打印机、输入机和进程之间共享的变量、数据。</p><p><strong>临界区</strong>：每个进程中，<strong>访问临界资源的</strong>那段<strong>代码</strong>。</p><p>内核程序临界区一般是<strong>用来访问某种内核数据结构</strong>的代码，比如进程的就绪队列（由各就绪进程的PCB组成)</p><p><font color="green"><strong>为什么进程在操作系统内核程序临界区不能进程调度？</strong></font></p><img src="\image\article\操作系统-进程管理\image-20220908214508621.png" alt="image-20220908214508621" style="zoom:67%;" /><p>如果还没退出临界区（还没解锁)就进行进程调度，但是进程调度相关的程序也需要访问就绪队列，但此时就绪队列被锁住了，因此<br>又无法顺利进行进程调度。</p><p>内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作【比如进程切换】。因此在访问内核程序临界区期间不能进行调度与切换</p><p><strong>进程在内核临界区  —–&gt;   CPU空闲   ——&gt;  内核临届资源被占用 ——&gt; 其他内核管理工作极可能受影响【比如进程切换】</strong> </p><p><strong>如果此时进行进程调度，就极可能受到影响，所以不能进行进程调度。</strong></p><p><font color="green"><strong>为什么进程在操作系统程序【非内核】临界区可以进程调度？</strong></font></p><p>比如，访问打印机。</p><img src="\image\article\操作系统-进程管理\image-20220908215122123.png" alt="image-20220908215122123" style="zoom:80%;" /><p>在打印机打印完成之前,进程一直处于临界区内，临界资源不会解锁。但<strong>打印机又是慢速设备</strong>，此时如果一直不允许进程调度的话就会导致CPU一直空闲</p><p><strong>进程在普通临界区 —–&gt;  CPU空闲  ——&gt;  临界资源被占用  ——&gt;  CPU一直空闲。</strong></p><p><strong>如果不允许进程调度的话，CPU会一直空闲</strong></p></blockquote><h2 id="进程调度方式"><a href="#进程调度方式" class="headerlink" title="进程调度方式"></a>进程调度方式</h2><ul><li><p><strong>非抢占式调度算法</strong>：</p><p>挑选一个进程，然后让该进程<strong>运行直到被阻塞，或者直到该进程退出，才会调用另外一个进程</strong>。</p><p>特点：实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统</p></li><li><p><strong>抢占式调度算法</strong>：</p><p>当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。</p><p>特点：可以优先处理更紧急的进程,也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统</p></li></ul><h2 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h2><p>进程切换的过程主要完成了:</p><ol><li>对原来运行进程各种数据的保存</li><li>对新的进程各种数据的恢复<br>(如:程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块)</li></ol><blockquote><p> 注意：<font color="red">进程切换是有代价的</font>，因此如果<font color="red">过于频繁的</font>进行<font color="red">进程调度、切换</font>，必然会使整个<font color="red">系统的效率降低</font>，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。【因此要使用合理的调度算法】</p></blockquote><h1 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h1><p>调度算法的评价指标：</p><p>CPU利用率：CPU处于忙碌的时间 占 总时间的比例。</p><p>吞吐量：单位时间内完成作业的数量   $系统吞吐量 &#x3D; \frac{总共完成了多少道作业}{总共花了多少时间}$</p><p>周转时间：</p><h2 id="先来先服务算法"><a href="#先来先服务算法" class="headerlink" title="先来先服务算法"></a>先来先服务算法</h2><p>主要从“公平”的角度考虑（类似于我们生活中排队买饭）</p><p>规则：按照作业&#x2F;进程到达的先后顺序进行服务。</p><p>可用于作业调度，也可用于进程调度。</p><p><img src="/%5Cimage%5Carticle%5C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%5Cimage-20220909140754844.png" alt="image-20220909140754844"></p><p><strong>每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。</strong></p><p>是一种<font color="red"><strong>非抢占式</strong></font>的调度算法。</p><ul><li><p>优点：公平、算法实现简单</p></li><li><p>缺点：排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。</p><p><strong>FCFS算法对长作业有利，对短作业不利。</strong></p></li></ul><p>适用于 CPU 繁忙型作业的系统，而不适用于 I&#x2F;O 繁忙型作业的系统。</p><p>不会导致<strong>进程饥饿</strong>。</p><h2 id="最短作业优先算法"><a href="#最短作业优先算法" class="headerlink" title="最短作业优先算法"></a>最短作业优先算法</h2><p>追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间</p><p>规则：<strong>优先选择<font color="red">运行时间最短</font>的进程来运行</strong>，这有助于提高系统的吞吐量。</p><p><img src="/%5Cimage%5Carticle%5C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%5Cimage-20220909141357885.png" alt="image-20220909141357885"></p><p>最短作业优先算法默认是非抢占式的，但<strong>也有抢占式的。</strong></p><blockquote><p>抢占式的最短作业优先算法，也称“最短剩余时间优先算法”：</p><p>当有进程加入 –&gt; 导致就绪队列改变 —&gt; 然后需要进行调度。</p><p>如果<strong>新到达的进程剩余时间</strong>比<strong>当前运行的进程剩余时间</strong>更短</p><p>则由新进程抢占处理机，当前运行进程重新回到就绪队列。另外，当一个进程完成时也需要调度</p></blockquote><ul><li><p>优点：“最短的”平均等待时间、平均周转时间</p></li><li><p>缺点：</p><ul><li><p>不公平。<font color="red"><strong>对短作业有利，对长作业不利</strong></font>。</p></li><li><p>可能产生<font color="blue"><strong>饥饿现象</strong></font>。</p><p>一个长作业在就绪队列等待运行，而这个就绪队列有非常多的短作业，那么就会使得长作业不断的往后推，周转时间变长，致使长作业长期不会被运行。如果一直得不到服务，则称为”饿死“</p></li><li><p>作业&#x2F;进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先</p></li></ul></li></ul><h2 id="高响应比优先调度算法"><a href="#高响应比优先调度算法" class="headerlink" title="高响应比优先调度算法"></a>高响应比优先调度算法</h2><p>综合考虑作业&#x2F;进程的<font color="red">等待时间</font>和<font color="red">要求服务的时间</font>。</p><p>前面的「先来先服务调度算法」和「最短作业优先调度算法」都没有很好的权衡短作业和长作业。</p><p>那么，<strong>高响应比优先 （Highest Response Ratio Next, HRRN）调度算法</strong>主要是权衡了短作业和长作业。</p><p>「响应比优先级」的计算公式：<br>$$<br>优先级 &#x3D; \frac{等待时间+要求服务时间}{要求服务时间}{(优先级\geq1)}<br>$$<br>每次进行进程调度时</p><ol><li>先计算「响应比优先级」</li><li>然后把「响应比优先级」<strong>最高</strong>的进程投入运行</li></ol><blockquote><p>现实中，进程要求服务的时间是不可预估的。所以，高响应比优先调度算法是「理想型」的调度算法，现实中是实现不了的。</p></blockquote><p>该算法是<font color="blue"><strong>非抢占式的</strong></font>，因此只有当前运行的作业&#x2F;进程主动放弃处理机时，才需要调度，才需要计算响应比。</p><p>优点：</p><p>综合考虑了等待时间和运行时间（要求服务时间)</p><p>等待时间相同时，要求服务时间短的优先(SJF的优点）</p><p>要求服务时间相同时，等待时间长的优先(FCFS的优点)</p><p>对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题</p><h2 id="时间片轮转调度算法"><a href="#时间片轮转调度算法" class="headerlink" title="时间片轮转调度算法"></a>时间片轮转调度算法</h2><p>按照各进程到达就绪队列的顺序，轮流让各个进程执行一个<font color="red"><strong>时间片（如100ms）</strong></font>。</p><p>若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。</p><p><img src="/%5Cimage%5Carticle%5C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%5Cimage-20220909145213669.png" alt="image-20220909145213669"></p><p>是一种抢占式调度算法，</p><p>若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于<strong>抢占式的算法</strong>。由时钟装置发出时钟中断来通知CPU时间片已到。</p><blockquote><p>时间片的长度就是一个很关键的点：</p><ul><li><strong>时间片设得太短</strong>：会导致过多的进程上下文切换，降低了 CPU 效率；</li><li><strong>时间片设得太长</strong>：使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。</li></ul><p>一般来说，时间片设为 <code>20ms~50ms</code> 通常是一个比较合理的折中值。</p></blockquote><h2 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h2><p>每个作业&#x2F;进程有<strong>各自的优先级</strong>，调度时从就绪队列<strong>选择优先级最高</strong>的作业&#x2F;进程。</p><p>进程的优先级可以分为，<font color="blue"><strong>静态优先级</strong></font>和<font color="blue"><strong>动态优先级</strong></font>：</p><ul><li><p>静态优先级：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化；</p></li><li><p>动态优先级：</p><p>根据进程的动态变化调整优先级</p><p>比如如果进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是<strong>随着时间的推移增加等待进程的优先级</strong>。</p></li></ul><p>该算法也有两种处理优先级高的方法，<font color="blue"><strong>非抢占式</strong></font>和<font color="blue"><strong>抢占式</strong></font>：</p><ul><li>非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。</li><li>抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。</li></ul><p>优点和缺点：</p><ul><li>优点：用优先级区分紧急程度、重要程度，适用于实时操作系统。可<strong>灵活地调整对各种作业&#x2F;进程的偏好程度</strong>。</li><li>缺点：若源源不断地有高优先级进程到来，则可能导致饥饿</li></ul><h2 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h2><p><strong>多级反馈队列（*Multilevel Feedback Queue*）调度算法</strong>是「时间片轮转算法」和「最高优先级算法」的综合和发展。</p><ul><li>「多级」表示有多个队列，每个队列优先级从高到低，同时<font color="red"><strong>优先级越高时间片越短</strong></font>。</li><li>「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列；</li></ul><img src="\image\article\操作系统-进程管理\image-20220909151926863.png" alt="image-20220909151926863" style="zoom:80%;" /><p>用一个例子来进行说明：</p><p>如下进程：</p><table><thead><tr><th align="center">进程</th><th align="center">到达时间</th><th align="center">运行时间</th></tr></thead><tbody><tr><td align="center"><code>P1</code></td><td align="center">0</td><td align="center">8</td></tr><tr><td align="center"><code>P2</code></td><td align="center">1</td><td align="center">4</td></tr><tr><td align="center"><code>P3</code></td><td align="center">5</td><td align="center">1</td></tr></tbody></table><p>多级反馈队列</p><img src="\image\article\操作系统-进程管理\image-20220909152139158.png" alt="image-20220909152139158" style="zoom:67%;" /><ul><li>第一级就绪队列的时间片大小为1</li><li>第二级就绪队列的时间片大小为2</li><li>第三级就绪队列的时间片大小为4</li></ul><h4 id="0时刻"><a href="#0时刻" class="headerlink" title="0时刻"></a>0时刻</h4><p>P1到达，先放入第一级队列，此时也没有别的进程，由于它在第一级队列，所以它被分配 1 个时间片。</p><img src="\image\article\操作系统-进程管理\image-20220909152420743.png" alt="image-20220909152420743" style="zoom:67%;" /><p>当过了 1 个时间的时候，P1的时间片用完了。所以它会进入下一级队列的队尾【第2级队列】</p><img src="\image\article\操作系统-进程管理\image-20220909152544695.png" alt="image-20220909152544695" style="zoom:67%;" /><h4 id="1时刻"><a href="#1时刻" class="headerlink" title="1时刻"></a>1时刻</h4><p>P2到达，进入第一级队列，P1执行完了，P2紧随其后。</p><img src="\image\article\操作系统-进程管理\image-20220909152731253.png" alt="image-20220909152731253" style="zoom:67%;" /><p>此时第 1 级队列不是空的，所以不会处理第2级队列的进程。因此这个时刻会调度P2这个进程，来进行处理。</p><img src="\image\article\操作系统-进程管理\image-20220909152912292.png" alt="image-20220909152912292" style="zoom:67%;" /><p>同样的，P2只运行一个单位时间的时间片。运行完后，会放入下一级队列的队尾。</p><img src="\image\article\操作系统-进程管理\image-20220909153027084.png" alt="image-20220909153027084" style="zoom:67%;" /><h4 id="2时刻"><a href="#2时刻" class="headerlink" title="2时刻"></a>2时刻</h4><p>没有进程到达，且第一级队列为空，所以才会处理第二级队列的进程。为第二级队列的<strong>队头</strong>【即P1】分配一个<strong>2个时间单位</strong>的时间片。</p><p>P1被处理机调度。</p><img src="\image\article\操作系统-进程管理\image-20220909153317696.png" alt="image-20220909153317696" style="zoom:67%;" /><p>P1执行两个单位时间的时间片后结束。P1的运行时间没有结束，还会放入<strong>下一级队列的队尾</strong>。</p><img src="\image\article\操作系统-进程管理\image-20220909153439751.png" alt="image-20220909153439751" style="zoom:67%;" /><h4 id="4时刻"><a href="#4时刻" class="headerlink" title="4时刻"></a>4时刻</h4><p>没有进程到达，第一级队列为空，第二级队列不为空，为<strong>第二级队列的队头</strong>分配一个<strong>2个时间单位</strong>的时间片。</p><img src="\image\article\操作系统-进程管理\image-20220909153616819.png" alt="image-20220909153616819" style="zoom:67%;" /><h4 id="5时刻"><a href="#5时刻" class="headerlink" title="5时刻"></a>5时刻</h4><p>P3进程到达，进入第一级队列。</p><img src="\image\article\操作系统-进程管理\image-20220909153851875.png" alt="image-20220909153851875" style="zoom:67%;" /><p>此时P3所在队列的<font color="red"><strong>优先级更高</strong></font>，P2还没有运行完，此时P2被剥夺处理机。</p><p><font color="blue">但是，P2的时间片还没有用完，它没有放入下一级队列，而是放回当前<strong>队列的队尾</strong></font>。P3被调度，分配一个单位的时间片。</p><img src="\image\article\操作系统-进程管理\image-20220909154328959.png" alt="image-20220909154328959" style="zoom:67%;" /><p>P3运行一个单位时间后，P3运行完成。然后被调出内存。</p><img src="\image\article\操作系统-进程管理\image-20220909154426952.png" alt="image-20220909154426952" style="zoom:67%;" /><h4 id="6时刻"><a href="#6时刻" class="headerlink" title="6时刻"></a>6时刻</h4><p>第一级队列为空，第二级队列的队头，被调度，P2继续运行，P2运行两个单位的时间片。【不是运行上次剩余的一个单位的时间片】</p><img src="\image\article\操作系统-进程管理\image-20220909155131054.png" alt="image-20220909155131054" style="zoom:67%;" /><p>然后，P2运行结束【总共运行了4个单位的时间片】，被调离内存。</p><img src="\image\article\操作系统-进程管理\image-20220909155233794.png" alt="image-20220909155233794" style="zoom:67%;" /><h4 id="8时刻"><a href="#8时刻" class="headerlink" title="8时刻"></a>8时刻</h4><p>此时，第1级队列 和 第二级队列 都是空的，此时调度第三级队列的队头元素【P1】。给P1分配 <strong>4 个单位时间的时间片</strong>。</p><img src="\image\article\操作系统-进程管理\image-20220909155357725.png" alt="image-20220909155357725" style="zoom:67%;" /><h4 id="12时刻"><a href="#12时刻" class="headerlink" title="12时刻"></a>12时刻</h4><p>P1,运行结束，但它所处的队列以及是最低级队列，没法再放入在低一级的了。所以，又放回第三级队列。</p><img src="\image\article\操作系统-进程管理\image-20220909155634897.png" alt="image-20220909155634897" style="zoom:67%;" /><p>然后只剩它一个了，再次被调度，分配 <strong>4 个单位时间的时间片</strong>。</p><p>用了一个单位时间就结束了。被调离内存。</p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ol><li><p>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</p></li><li><p>新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片</p><p>若用完时间片进程还未结束，则进程<strong>进入下一级队列队尾</strong>。</p><p>若此时已经是在最下级的队列，则重新放回该队列队尾</p></li><li><p>只有第k级队列为空时，才会为k+1级队头的进程分配时间片</p></li><li><p><font color="red"><strong>抢占式的算法</strong></font>。</p><p>在k级队列的进程运行过程中</p><p>若更上级的队列(1 ~ k-1级）中进入了一个新进程</p><p>则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾。</p></li></ol><blockquote><p>对于短作业可能可以在第一级队列很快被处理完。</p><p>对于长作业，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也变更长了，所以该算法很好的<strong>兼顾了长短作业，同时有较好的响应时间。</strong></p><p>但该算法，如果遇到有源源不断的短进程到达，会引起<strong>长进程的饥饿</strong></p></blockquote>]]></content>
    
    
    <summary type="html">处理机的调度、调度的三个层次、调度是时机方式以及调度算法。</summary>
    
    
    
    <category term="操作系统" scheme="http://example.com/category/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="进程管理" scheme="http://example.com/tag/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>三大余数定理[算法]</title>
    <link href="http://example.com/post/70577aa4.html"/>
    <id>http://example.com/post/70577aa4.html</id>
    <published>2022-09-08T01:50:57.000Z</published>
    <updated>2022-09-08T04:04:16.214Z</updated>
    
    <content type="html"><![CDATA[<p>最近做算法题的时候，又用到了余数定理，之前做Leetcode的时候，做过一道**<a href="https://leetcode.cn/problems/continuous-subarray-sum/">连续子数组和</a>**的时候，就用到了同余定理。因此在此做一下总结。</p><h2 id="余数的加法定理"><a href="#余数的加法定理" class="headerlink" title="余数的加法定理"></a>余数的加法定理</h2><p>a 与b的和除以c的余数，等于a,b分别除以c的余数之和，或这个和除以c的余数。<br>$$<br>(a+b) % c &#x3D; a%c + b%c<br>$$<br>当余数的和比除数大时，<strong>所求的余数等于余数之和再除以c的余数。</strong></p><h2 id="余数的乘法定理"><a href="#余数的乘法定理" class="headerlink" title="余数的乘法定理"></a>余数的乘法定理</h2><p>a与b的乘积除以c的余数，等于a,b分别除以c的余数的积，或者这个积除以c所得的余数。<br>$$<br>(a<em>b)%c &#x3D; (a%c)</em>(b%c)<br>$$<br>例如：<br>$$<br>23%5 &#x3D; 3;16%5&#x3D;1 \Longrightarrow  (23<em>16)%5 &#x3D; 3</em>1&#x3D;3<br>$$<br>当余数的和比除数大时，所求的余数等于余数之积再除以的余数。</p><p>这个定理的一个应用就是，<strong>大数幂取余</strong>。</p><p>最近做的一道题是，给了三个数，比如 m，n，k。求$ (m^n)%k$。</p><p>看似很简单，用<code>java</code>实现的话。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> Math.pow(m, n) % k;</span><br></pre></td></tr></table></figure><p>但是，如果$m&#x3D;4296,n&#x3D;1601,k&#x3D;4757的话，m^n将是非常大的数，超过了计算机能够表示的上限。$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> Math.pow(<span class="number">4096</span>, <span class="number">1601</span>)<span class="comment">//Infinity</span></span><br></pre></td></tr></table></figure><p>因此就不能使用这么简单的方法，于是就用到了余数的乘法定理。</p><p>$ m^n &#x3D; (m<em>m</em>m…)$</p><p>因此<br>$$<br>(m<em>m</em>m…)%k &#x3D; (m*…<em>(m</em>(m%k)%k)%k…)%k<br>$$<br>代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Dcrypt</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> m%k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            res = (res*m)%k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$4296^{1601}%4757&#x3D;228$</p><h2 id="同余定理"><a href="#同余定理" class="headerlink" title="同余定理"></a>同余定理</h2><p>若两个整数a、b被自然数m除有相同的余数，那么称a、b对于模m同余。<br>若两个数a，b除以同一个数m得到的余数相同，则a, b的差一定能被m整除。</p><p>即<br>$$<br>a%m &#x3D; b%m\Longrightarrow(a-b)%m&#x3D;0<br>$$<br>也就是说$a-b 是 m的倍数$</p><h2 id="连续的子数组和"><a href="#连续的子数组和" class="headerlink" title="连续的子数组和"></a><font color="red"><strong>连续的子数组和</strong></font></h2><p>给你一个整数数组<code>nums</code>和一个整数 k ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：</p><ul><li>子数组大小 至少为 2 ，且</li><li>子数组元素总和为 k 的倍数。</li></ul><p>如果存在，返回 true ；否则，返回 false 。</p><p>如果存在一个整数 n ，令整数 x 符合 x &#x3D; n * k ，则称 x 是 k 的一个倍数。0 始终视为 k 的一个倍数。</p><p><strong>示例1：</strong></p><blockquote><p>输入：nums &#x3D; [23,2,4,6,7], k &#x3D; 6<br>输出：true<br>解释：[2,4] 是一个大小为 2 的子数组，并且和为 6 。</p></blockquote><p><strong>示例2：</strong></p><blockquote><p>输入：nums &#x3D; [23,2,6,4,7], k &#x3D; 6<br>输出：true<br>解释：[23, 2, 6, 4, 7] 是大小为 5 的子数组，并且和为 42 。<br>42 是 6 的倍数，因为 42 &#x3D; 7 * 6 且 7 是一个整数。</p></blockquote><p><strong>示例3：</strong></p><blockquote><p>输入：nums &#x3D; [23,2,6,4,7], k &#x3D; 13<br>输出：false</p></blockquote><p>一般看到连续子数组，都会想到**<a href="https://blog.csdn.net/weixin_43155866/article/details/106378712">数组前缀和</a><strong>。这道题可以用暴力二重循环解，但是会</strong>超时**。</p><p>如果要在O(n)时间复杂度内解决，只能采用<strong>空间换时间</strong>的想法啦！</p><p>用哈希表来存储，数组前缀和与k的余数。<strong>key为余数，value为数组前缀和长度</strong>【数组下标】</p><p>使用同余定理，如果  <font color="blue"><strong>某一前缀和%k 所得余数 存在于哈希表中</strong></font>，那么说明 <strong>找到了同余</strong>。</p><p>此时可以确定存在子数组的和是k的倍数。然后判断长度是否小于2，这就用到了value了。</p><p>下面我们用图解说明吧</p><p>拿<code>nums = [23,2,4,6,7], k = 6</code>举例吧</p><p>初始如下</p><p><img src="/%5Cimage%5Carticle%5C%E4%B8%89%E5%A4%A7%E4%BD%99%E6%95%B0%E5%AE%9A%E7%90%86-%E7%AE%97%E6%B3%95%5Cimage-20220908113437512.png" alt="image-20220908113437512"></p><p>然后遍历数组，计算<strong>前缀和以及取余</strong></p><p><img src="/%5Cimage%5Carticle%5C%E4%B8%89%E5%A4%A7%E4%BD%99%E6%95%B0%E5%AE%9A%E7%90%86-%E7%AE%97%E6%B3%95%5Cimage-20220908113750934.png" alt="image-20220908113750934"></p><p>前缀和为23，$23%6&#x3D;5$，哈希表没有余数5，不存在同余。所以存入哈希表中。</p><p><img src="/%5Cimage%5Carticle%5C%E4%B8%89%E5%A4%A7%E4%BD%99%E6%95%B0%E5%AE%9A%E7%90%86-%E7%AE%97%E6%B3%95%5Cimage-20220908114026587.png" alt="image-20220908114026587"></p><p>前缀和为25，$25%6&#x3D;1$，哈希表没有余数1，不存在同余。所以存入哈希表中。</p><p><img src="/%5Cimage%5Carticle%5C%E4%B8%89%E5%A4%A7%E4%BD%99%E6%95%B0%E5%AE%9A%E7%90%86-%E7%AE%97%E6%B3%95%5Cimage-20220908114438178.png" alt="image-20220908114438178"></p><p>前缀和为29，$29%6&#x3D;5$，哈希表中存在余数5。即存在同余。</p><p><img src="/%5Cimage%5Carticle%5C%E4%B8%89%E5%A4%A7%E4%BD%99%E6%95%B0%E5%AE%9A%E7%90%86-%E7%AE%97%E6%B3%95%5Cimage-20220908115255437.png" alt="image-20220908115255437"></p><p>这两个前缀和数组，具有相同的余数。<br>$$<br>23%6&#x3D;5  \ and \ 29%6&#x3D;5<br>$$<br>则<br>$$<br>(29-23)%6&#x3D;0<br>$$<br>则<font color="red"><strong>子数组  [2,4]</strong></font>之和即为6的倍数。长度为 $2-0&#x3D;2$。满足条件。</p><p>因此返回true。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkSubarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(nums.length);</span><br><span class="line">        map.put(<span class="number">0</span>,-<span class="number">1</span>);<span class="comment">//初始化哈希表</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录前缀和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum+=nums[i];<span class="comment">//前缀和</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> sum % k;<span class="comment">//取余</span></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(x))</span><br><span class="line">                <span class="keyword">if</span>(i-map.get(x)&gt;=<span class="number">2</span>)<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//i-map.get(x)计算子数组长度</span></span><br><span class="line">            &#125;<span class="keyword">else</span> map.put(x,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">余数的加法定理，余数的乘法定理，同余定理</summary>
    
    
    
    <category term="数据结构与leetcode算法" scheme="http://example.com/category/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8Eleetcode%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="余数定理" scheme="http://example.com/tag/%E4%BD%99%E6%95%B0%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>操作系统-进程管理（一）</title>
    <link href="http://example.com/post/cf59d18a.html"/>
    <id>http://example.com/post/cf59d18a.html</id>
    <published>2022-09-05T07:45:09.000Z</published>
    <updated>2022-09-09T09:13:39.358Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h1><p>什么是进程？</p><p>其实进程就是<strong>运行着的程序</strong>，是一个指令序列。</p><p>进程实体：进程实体由三个部分组成，<strong>程序段、数据段、PCB</strong>。</p><ul><li>程序段：保存的是程序代码本身。</li><li>数据段：保存的是程序运行的过程中运行所需要的数据（如：变量）。</li><li>PCB：进程控制块，用来描述进程的各种信息。</li></ul><img src="\image\article\操作系统-进程管理\image-20220905155928075.png" alt="image-20220905155928075" style="zoom:67%;" /><p>我们把进程实体简称位进程。</p><p>所谓的创建进程，实质上是<font color="red"><strong>创建进程实体中的PCB</strong></font></p><p>撤销进程，实质上是<font color="red"><strong>撤销进程实体中的PCB</strong></font></p><blockquote><p>PCB是进程存在的唯一标志。</p><p>严格来说，进程实体和进程是不一样的。进程实体是<font color="blue">静态的</font>，进程是<font color="blue">动态的</font>。</p></blockquote><h2 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB"></a>进程控制块PCB</h2><p>在操作系统中，是用<strong>进程控制块</strong>（<em>process control block，PCB</em>）数据结构来描述进程的。</p><p><strong>PCB 是进程存在的唯一标识</strong>，这意味着一个进程的存在，必然会有一个 PCB，如果进程消失了，那么 PCB 也会随之消失</p><p>PCB包含的信息：</p><ul><li><p>进程描述信息</p><ul><li>进程标识符【PID】：标识各个进程，每个进程都有一个并且唯一的标识符；【可以理解位<strong>进程的ID</strong>】</li><li>用户标识符：进程归属的用户，用户标识符主要为共享和保护服务；</li></ul></li><li><p>进程控制和管理信息</p><ul><li>进程当前状态：如 new、ready(就绪态)、running(运行态)、waiting 或 blocked(阻塞态) 等；</li><li>进程优先级：进程抢占 CPU 时的优先级；</li></ul></li><li><p>资源分配清单【即该进程被分配了<strong>哪些系统资源</strong>】</p><ul><li>有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I&#x2F;O 设备信息。</li></ul></li><li><p>处理机相关信息</p><ul><li><p>CPU 中各个寄存器的值。</p><p>当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。</p></li></ul></li></ul><p><img src="/%5Cimage%5Carticle%5C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%5Cimage-20220905160900292.png" alt="image-20220905160900292"></p><h2 id="进程的组织"><a href="#进程的组织" class="headerlink" title="进程的组织"></a>进程的组织</h2><p>在一个系统中，通常由数十、数百乃至数千个PCB。为了对他们加以有效的管理，应当用适当的方式把这些PCB组织起来。</p><p>进程的组织方式：</p><ul><li>链接方式</li><li>索引方式</li></ul><h3 id="链接方式"><a href="#链接方式" class="headerlink" title="链接方式"></a>链接方式</h3><p>PCB通常是通过<strong>链表</strong>的方式进行组织，把具有<strong>相同状态的进程链在一起，组成各种队列</strong>。</p><p>比如：</p><ul><li>将所有处于就绪状态的进程链在一起，称为<font color="red"><strong>就绪队列</strong></font>；【通常会把优先级高的进程放在队头】</li><li>把所有因等待某事件而处于等待状态的进程链在一起就组成各种<font color="red"><strong>阻塞队列</strong></font>；【很多操作系统会根据阻塞原因不同，再分为多个队列】</li><li>对于<font color="red"><strong>运行队列</strong></font>在<font color="blue">单核 CPU 系统</font>中则只有<font color="blue">一个运行指针</font>了，因为单核 CPU 在某个时间，只能运行一个程序。</li></ul><img src="\image\article\操作系统-进程管理\image-20220905161507607.png" alt="image-20220905161507607" style="zoom:67%;" /><h3 id="索引方式"><a href="#索引方式" class="headerlink" title="索引方式"></a>索引方式</h3><p>它的工作原理：将同一状态的进程组织在一个索引表中，索引表项指向相应的 PCB，不同状态对应不同的索引表。</p><p>它和链接方式很类似</p><img src="\image\article\操作系统-进程管理\image-20220905161814030.png" alt="image-20220905161814030" style="zoom:67%;" /><h1 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h1><p>进程的状态由五种：</p><ul><li><p><font color="red"><strong>运行状态</strong></font>：占用CPU，并在CPU上运行。【多核CPU，可以有多个程序处于运行态，单核CPU，只能由一个程序处于运行态】</p></li><li><p><font color="red"><strong>就绪状态</strong></font>：已经具备的运行条件，但由于没有空闲的CPU，而暂时不能运行<strong>【万事具备，只欠CPU】</strong></p></li><li><p><font color="red"><strong>阻塞状态</strong></font>：因等待某一事件而暂时不能运行。【比如：等待用户输入，等待读磁盘操作】</p></li><li><p>创建状态：程序正在被创建，操作系统为进程分配资源，初始化PCB</p></li><li><p>终止状态：进程正在从系统撤销，操作系统会回收进程拥有的资源、撤销PCB。</p></li></ul><p>其中，运行状态、就绪状态和阻塞状态是<strong>三种基本状态</strong>。</p><p>状态转换</p><p><img src="/%5Cimage%5Carticle%5C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%5Cimage-20220905164843230.png" alt="image-20220905164843230"></p><blockquote><p>运行态 —–&gt; 阻塞态是一种进程自身做出的<font color="red">主动行为</font></p><p>阻塞态 —–&gt; 就绪态不是进程自身能控制的，是一种<font color="red">被动行为</font></p><p>注意：</p><ul><li>不能由阻塞态直接转换为运行态</li><li>不能由就绪态直接转换为阻塞态</li></ul></blockquote><h1 id="进程的控制"><a href="#进程的控制" class="headerlink" title="进程的控制"></a>进程的控制</h1><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，他具有以下功能：</p><ul><li>创建新进程</li><li>撤销已有进程</li><li>实现进程状态转换等</li></ul><p>其实，<strong>进程控制就是实现进程的状态转换</strong></p><h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><p>创建进程，进程会从<strong>创建态</strong>，转换为，<strong>就绪态</strong>【创建态 —-&gt; 就绪态】</p><img src="\image\article\操作系统-进程管理\image-20220905200645460.png" alt="image-20220905200645460" style="zoom: 50%;" /><p>过程如下：</p><ol><li><strong>申请一个空白的 PCB，并向 PCB 中填写一些控制和管理进程的信息</strong>，比如进程的唯一标识等；</li><li>为该进程<strong>分配运行时所必需的资源</strong>，比如内存资源；</li><li><strong>将 PCB 插入到就绪队列</strong>，等待被调度运行；</li></ol><h3 id="阻塞进程"><a href="#阻塞进程" class="headerlink" title="阻塞进程"></a>阻塞进程</h3><p>当进程需要<strong>等待某一事件完成</strong>时，它可以调用阻塞语句把自己阻塞等待。而一旦被阻塞等待，它只能由另一个进程唤醒。</p><img src="\image\article\操作系统-进程管理\image-20220905201435819.png" alt="image-20220905201435819" style="zoom:50%;" /><p>过程如下：</p><ol><li>找到将要被阻塞进程标识号对应的 PCB</li><li>如果该进程为运行状态，则<strong>保护其现场</strong>，将其状态转为阻塞状态，停止运行；</li><li><strong>将该 PCB 插入到阻塞队列中去</strong>；</li></ol><h3 id="唤醒进程"><a href="#唤醒进程" class="headerlink" title="唤醒进程"></a>唤醒进程</h3><p>进程由「运行」转变为「阻塞」状态是由于进程必须等待某一事件的完成，所以<font color="red">处于阻塞状态的进程是绝对不可能叫醒自己的</font>。</p><p>【不可能自己叫醒自己】</p><p>如果某进程正在等待 I&#x2F;O 事件，<strong>需由别的进程发消息给它</strong>，则只有当该进程所期待的事件出现时，才由发现者进程用唤醒语句叫醒它。</p><img src="\image\article\操作系统-进程管理\image-20220905201857890.png" alt="image-20220905201857890" style="zoom:50%;" /><ol><li>在该事件的阻塞队列中找到相应进程的 PCB；【如果是等待的是资源分配，则还需要为进程分配资源】</li><li>将其从阻塞队列中移出，并置其状态为就绪状态；</li><li>把该 PCB 插入到就绪队列中，等待调度程序调度；</li></ol><p>进程的<strong>阻塞和唤醒</strong>是一对功能相反的语句，如果某个进程调用了阻塞语句，则必有一个与之对应的唤醒语句</p><h3 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h3><img src="\image\article\操作系统-进程管理\image-20220905202145855.png" alt="image-20220905202145855" style="zoom:50%;" /><p>进程可以有 3 种终止方式：</p><ul><li>正常结束</li><li>异常结束【除0，数组越界····】</li><li>外界干预（信号 <code>kill</code> 掉）。</li></ul><p>当子进程被终止时，其在父进程处继承的资源应当还给父进程。而当父进程被终止时，该父进程的子进程就变为孤儿进程，会被 1 号进程收养，并由 1 号进程对它们完成状态收集工作。</p><p>终止进程的过程如下：</p><ul><li>查找需要终止的进程的 PCB；</li><li>如果处于执行状态，则立即终止该进程的执行，然后将 CPU 资源分配给其他进程；</li><li>如果其还有子进程，则应将该进程的子进程交给 1 号进程接管；</li><li>将该进程所拥有的全部资源都归还给操作系统；</li><li>将其从 PCB 所在队列中删除；</li></ul><h3 id="原语"><a href="#原语" class="headerlink" title="原语"></a>原语</h3><p>进程控制的实现是使用<strong>原语</strong>实现的</p><p>原语的特点是：<font color="red">执行期间不允许中断，只能一气呵成。</font>【这种不可被中断的操作即<font color="blue"><strong>原子操作</strong></font>】</p><p>原语是一种特殊的程序，采用   “关中断指令”   和  “开中断指令“实现。</p><img src="\image\article\操作系统-进程管理\image-20220905203006828.png" alt="image-20220905203006828" style="zoom:67%;" /><p><font color="red">关&#x2F;开中断指令</font>的权限非常大，必然只允许在<font color="red">核心态</font>下执行。</p><h1 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h1><p>进程是分配系统资源的单位，因此<font color="red">各进程</font>拥有的<font color="red">内存地址空间相互独立</font>。</p><img src="\image\article\操作系统-进程管理\image-20220905203711326.png" alt="image-20220905203711326" style="zoom:50%;" /><p>进程1可以访问进程1的地址空间，进程2可以访问进程2的地址空间，但进程1无法访问进程2的地址空间。如果可以，这是非常危险，进程1就可以篡改进程2的数据，是非常不安全的。</p><p>为了保证安全，<font color='red'>一个进程是不能直接访问另一个进程的地址空间的</font>。</p><p>但是进程之间的信息交换又是必须实现的。为了保证进程间的安全通信，操作系统提供了一些方法。</p><p>比如：你可以将浏览器的照片通过QQ分享给你的朋友。</p><p>进程通信可以使用以下三种方式实现</p><ul><li>共享存储</li><li>消息传递</li><li>管道通信</li></ul><h2 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h2><p>所谓的管道，是指用于<font color="red">连接读写进程的一个<strong>共享文件</strong></font>，又名pipe文件。其实就是<font color="blue"><strong>在内存中开辟一个大小固定的缓冲区</strong></font>。</p><p><img src="/%5Cimage%5Carticle%5C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%5Cimage-20220905204739438.png" alt="image-20220905204739438"></p><p>管道只能采用<font color="red">半双工通信</font>【单向传输】。如果要实现全双工通信，则需要设置两个管道。</p><p>各进程要<font color="red">互斥</font>地访问管道【进程1向管道写数据的时候，进程2是不可以读数据的】</p><p>通信过程：</p><ul><li>数据以<font color="blue">字符流</font>的形式写入管道，当<font color="red">管道写满</font>时，写进程的<code>write()</code>系统调用将被阻塞，等待读进程将数据取走。</li><li>当读进程将数据全部取走后，<font color="red">管道变空</font>，此时读进程的<code>read()</code>系统调用将被阻塞。</li></ul><blockquote><p>注意：</p><p>如果没有写满，是不允许读的。如果没有读空，是不允许写的。</p><p>数据一旦被读出，就从管道中被抛弃，这就意味着<font color="red">读进程最多只能由一个</font>，否则可能会有读错数据的情况。</p></blockquote><p> <font size=4>管道这种通信方式效率低，不适合进程间频繁地交换数据</font></p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>进程间的数据交换以<font color="red">格式化的消息</font>为单位。进程通过操作系统提供的  <strong>”发送消息&#x2F;接收消息“</strong>  两个原语进行数据交换。</p><p>一个格式化的消息分为：<strong>消息头</strong>   和   <strong>消息体</strong>   两部分</p><p><img src="/%5Cimage%5Carticle%5C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%5Cimage-20220905214501470.png" alt="image-20220905214501470"></p><p>每个进程会有一个消息缓冲队列，<strong>消息队列是保存在<font color="red">内核</font>中的消息链表</strong></p><p>通信过程：</p><ol><li><p>如果由另外一个进程向此进程发送消息，这个进程会首先创建好一个<font color="red"><strong>格式化的消息体</strong></font>。</p><p>消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。</p></li><li><p>这个消息体会通过<font color="red"><strong>发送原语</strong></font>发送给目标进程。</p></li><li><p>这个消息就会挂到目标进程的<font color="red"><strong>消息缓存队列的队尾</strong></font>。</p></li><li><p>目标进程会通过<font color="red"><strong>接收原语</strong></font>依次把这些队列的消息一个一个取走，处理。</p><p>如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。</p></li></ol><p><img src="/%5Cimage%5Carticle%5C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%5Cimage-20220905220437109.png" alt="image-20220905220437109"></p><h3 id="消息队列和管道的比较"><a href="#消息队列和管道的比较" class="headerlink" title="消息队列和管道的比较"></a>消息队列和管道的比较</h3><ul><li>生命周期<ul><li><strong>消息队列</strong>生命周期<font color="red">随内核</font>，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在</li><li><strong>管道</strong>的生命周期，是<font color="red">随进程的创建而建立，随进程的结束而销毁</font>。</li></ul></li><li>数据格式<ul><li>每个消息体都是固定大小的存储块</li><li>管道是无格式的字节流数据</li></ul></li></ul><h3 id="消息队列的不足"><a href="#消息队列的不足" class="headerlink" title="消息队列的不足"></a>消息队列的不足</h3><p>消息队列这种模型，两个进程之间的通信就像平时发邮件一样，你来一封，我回一封，可以频繁沟通了。</p><p>但邮件的通信方式存在不足的地方有两点，<font color="blue"><strong>一是通信不及时，二是附件也有大小限制</strong></font>，这同样也是消息队列通信不足的点。</p><ul><li><p><strong>消息队列不适合比较大数据的传输</strong></p><p>因为在内核中每个消息体都有一个<font color="red">最大长度的限制</font>，同时所有<font color="red">队列所包含的全部<strong>消息体的总长度</strong>也是有上限</font></p></li><li><p><strong>消息队列通信过程中，存在用户态与内核态之间的<font color="red">数据拷贝开销</font></strong></p><p>进程写入数据到内核中的消息队列时，会发生<strong>从<font color="blue">用户态</font>拷贝数据到<font color="blue">内核态</font>的过程</strong></p><p>另一进程读取内核中的消息数据时，会发生<strong>从<font color="blue">内核态</font>拷贝数据到<font color="blue">用户态</font>的过程</strong>。</p></li></ul><h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程。那<strong>共享内存</strong>的方式，就很好的解决了这一问题。</p><p>两个进程不能直接访问对方的进程的地址空间。所以操作系统会为两个进程开辟一块<strong>共享空间</strong>。</p><img src="\image\article\操作系统-进程管理\image-20220905221543493.png" alt="image-20220905221543493" style="zoom: 67%;" /><p><strong>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中</strong>。</p><p>这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。</p><blockquote><p>需要注意的是：两个进程对共享空间的访问必须的**<font color="red">互斥</font>**的</p><p>当进程A向内存写数据时，进程B是不允许访问共享空间的。</p></blockquote><h1 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h1><p>单核的 CPU 在某一个瞬间，只能运行一个进程。但在 1 秒钟期间，它可能会运行多个进程，这样就产生<strong>并行的错觉</strong>，实际上这是<strong>并发</strong>。</p><p>并发是指能<strong>处理多个同时事件</strong>，并行是指<strong>同时处理两个事件</strong>。</p><p>单核CPU只能并发处理进程，多核CPU才能并行处理多个进程。</p><img src="\image\article\操作系统-进程管理\image-20220907194231325.png" alt="image-20220907194231325" style="zoom: 80%;" /><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="为什么要引入线程"><a href="#为什么要引入线程" class="headerlink" title="为什么要引入线程"></a>为什么要引入线程</h2><p>还没有引入线程之前，系统中各个程序只能串行执行。</p><blockquote><p> 如果我们打开一个QQ程序，</p><p>加入没有引入线程：我们要么进行视频聊天，要么进行文字聊天，而且只能和一个人。</p><p>在引入线程之后：我们课进行视频聊天的同时和其他人进行文字聊天。</p></blockquote><p>有的进程可能需要”同时“处理很多事，而传统的进程只能<font color="red"><strong>串行地执行一系列程序代码</strong></font>。为此，引入线程来增加并发度。 </p><p><strong>传统的进程是执行流的最小单位</strong> ，CPU会轮流执行这些进程。</p><img src="\image\article\操作系统-进程管理\image-20220907200326129.png" alt="image-20220907200326129" style="zoom:80%;" /><p>而引入线程之后，CPU调度的最小单位不再是进程，而是线程。CPU会用一些算法，轮流执行这些线程。</p><img src="\image\article\操作系统-进程管理\image-20220907200631217.png" alt="image-20220907200631217" style="zoom:80%;" /><p>引入线程后，<font color="red" size=4><strong>线程成为了程序执行流的最小单位</strong></font></p><p>我们可以把线程理解为“轻量级进程”</p><p>引入线程之后，不仅<font color="blue"><strong>进程之间可以并发执行</strong></font>，<font color="green"><strong>进程间的各个线程之间也可以并发的执行</strong></font>。从而进一步提高了并发度。</p><p>进程只作为除CPU之后的系统资源分配单元。（如打印机、内存地址等都是分配给进程的）</p><blockquote><p><strong>线程是进程当中的一条执行流程。</strong></p><p>同一个进程内多个线程之间可以<font color="red"><strong>共享代码段、数据段、打开的文件等资源</strong></font>，但<font color="blue"><strong>每个线程各自都有一套独立的寄存器和栈</strong></font>，这样可以确保线程的控制流是相对独立的。</p></blockquote><h2 id="线程和进程的比较"><a href="#线程和进程的比较" class="headerlink" title="线程和进程的比较"></a>线程和进程的比较</h2><p>比较如下：</p><ul><li><font color="blue">进程</font>是<font color="blue"><strong>资源分配</strong></font>（包括内存、打开的文件等）的单位，<font color="red">线程</font>是<font color="red"> <strong>CPU 调度</strong></font>的单位；</li><li>【资源方面】进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如<strong>寄存器和栈</strong>；【线程几乎不拥有系统资源】</li><li>【状态方面】线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；【状态方面，和进程状态差不多类似】</li><li>【开销方面】线程能<strong>减少并发执行的时间和空间开销</strong>；</li></ul><blockquote><p> 为什么会减少并发执行的<strong>时间和空间开销呢</strong>？</p><ul><li><p><font color="blue">线程的创建时间比进程<u>快</u></font></p><ul><li>进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，</li><li>线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；</li></ul></li><li><p><font color="blue">线程的终止时间比进程快</font></p><ul><li>线程释放的资源相比进程少很多</li></ul></li><li><p><font color="blue"><strong>同一个进程内的线程</strong>切换比进程切换快</font></p><ul><li>对于同一个进程的线程之间的切换，线程具有相同的地址空间（虚拟内存共享），这意味着在切换的时候不需要切换页表。</li><li>而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；</li></ul></li><li><p><font color="blue"><strong>同一进程的各线程</strong>之间的数据交互效率更高</font></p><ul><li><p>同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了。</p><p>【由于共享内存地址空间，同一进程中的线程通信甚至无需系统干预】</p></li></ul></li></ul></blockquote><p>同一进程内的线程切换，不需要切换进程环境，系统开销小。</p><p>但是不同进程的线程切换，则需要切换进程，系统开销大。</p><h2 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h2><p>线程的实现方式基本有两种：</p><ul><li>用户级线程：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理；</li><li>内核级线程：在内核中实现的线程，是由内核管理的线程；</li></ul><h3 id="如何理解用户级线程呢？"><a href="#如何理解用户级线程呢？" class="headerlink" title="如何理解用户级线程呢？"></a>如何理解<strong>用户级线程</strong>呢？</h3><p>可以回想一下，进程是如何实现的呢？也就是说进程是如何控制的呢？</p><p>进程的控制是由<strong>原语</strong>实现的，而原语是一段特殊的程序，其中包含 <strong>开&#x2F;关中断</strong> 。而开关中断是特权指令，必须在核心态下执行。</p><p>所以，<strong>进程的控制是由操作系统来实现的。</strong></p><p>而用户级线程是<strong>用函数库来实现线程</strong>。所有的线程管理工作都由<strong>函数库来管理</strong>。</p><blockquote><p>为什么要有用户级线程呢？</p><p>很久很久之前，线程的概念是出现了，但操作系统厂商可不能直接就去修改操作系统的内核，因为对他们来说，<strong>稳定性</strong>是最重要的。贸然把未经验证的东西加入内核，出问题了怎么办？所以想要验证线程的可用性，得另想办法。</p><p>所以，<font color="red">当初 用户级线程的出现是为了<strong>验证线程的稳定性等功能。</strong></font></p><p>那些研究人员就编写了一个关于线程的函数库，<strong>用函数库来实现线程</strong>！</p></blockquote><p>这个函数库实现了线程，还能进行管理。</p><p>比如<strong>创建线程</strong>、<strong>终止线程</strong>等功能放在了这个<strong>线程库</strong>内，用户就可以通过调用这些函数来实现所需要的功能。</p><p><font color="red" size=5>但是！</font></p><p>刚刚我们说的线程库，是位于用户空间的，<strong>操作系统内核对这个库一无所知</strong>，所以从内核的角度看，它还是按正常的方式管理。也就是说<strong>操作系统眼里还是只有进程</strong>，用线程库写的一个多线程进程，只能一次在<strong>一个 CPU 核心</strong>上运行。</p><p>由于操作系统只能看到进程的存在，那如果<strong>某一个线程阻塞</strong>了。在操作系统眼里，是进程阻塞了，那么整个进程就会进入<strong>阻塞态</strong>，在阻塞操作结束前，这个进程都无法得到 CPU 资源。那就相当于，<strong>所有的线程都被阻塞</strong>了。</p><blockquote><p>对于内核级线程，在用户看来，是有多个线程。但是在操作系统看来，并意识不到线程的存在。</p></blockquote><img src="\image\article\操作系统-进程管理\image-20220907214359952.png" alt="image-20220907214359952" style="zoom:80%;" /><h3 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h3><p>内核级线程的管理工作由操作系统内核完成。<strong>线程调度、切换等工作都由内核负责</strong>，因此内核级的切换必然需要在核心态下才能完成。</p><p>内核级线程的实现，使得操作系统内核知道线程的存在，就可以像调度多个进程一样，把这些线程放在好几个 CPU 核心上，就能做到实际上的<strong>并行</strong>了。</p><p><strong>假如线程 A 阻塞了，与他同属一个进程的线程也不会被阻塞</strong>。这是内核级线程的绝对优势。</p><img src="\image\article\操作系统-进程管理\image-20220907214422818.png" alt="image-20220907214422818" style="zoom: 67%;" /><h3 id="用户线程和内核线程的对应关系"><a href="#用户线程和内核线程的对应关系" class="headerlink" title="用户线程和内核线程的对应关系"></a>用户线程和内核线程的对应关系</h3><p>有的操作系统中只支持用户级线程，有的操作系统只支持内核级线程。有的操作系统两种都支持。</p><p>在同时支持用户级线程和内核级线程的系统中，可采用二者组合的方式：将n个用户级线程映射到m个内核级线程上。（n&gt;&#x3D;m）</p><blockquote><p>需要注意的是：</p><p>操作系统只看得见内核级线程，所以<font color="red">内核级线程才是处理机分配的单位</font>。</p></blockquote><p>由几个用户级线程映射到几个内核级线程的问题引出了“多线程模型”问题。</p><h4 id="多对一模型"><a href="#多对一模型" class="headerlink" title="多对一模型"></a>多对一模型</h4><p><strong>多对一模型</strong>:多个用户级线程映射到一个内核级线程。<font color="blue"><strong>每个用户进程只对应一个内核级线程</strong></font>。</p><img src="\image\article\操作系统-进程管理\image-20220907215103163.png" alt="image-20220907215103163" style="zoom:67%;" /><p>优点：用户级线程的切换在用户空间即可完成，<strong>不需要切换到核心态，线程管理的系统开销小，效率高。</strong></p><p>缺点：<strong>当一个用户级线程被阻塞后，整个进程都会被阻塞</strong>，并发度不高。<strong>多个线程不可在多核处理机上<u>并行</u>运行</strong></p><h4 id="一对一模型"><a href="#一对一模型" class="headerlink" title="一对一模型"></a>一对一模型</h4><p><strong>一对一模型</strong>：一个用户及线程映射到一个内核级线程。<font color="blue"><strong>每个用户进程有与用户级线程同数量的内核级线程。</strong></font></p><img src="\image\article\操作系统-进程管理\image-20220907215907528.png" alt="image-20220907215907528" style="zoom:80%;" /><p>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</p><p>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</p><h4 id="多对多模型"><a href="#多对多模型" class="headerlink" title="多对多模型"></a>多对多模型</h4><p>多对多模型：n个用户及线程映射到m个内核级线程(n &gt;&#x3D; m） 。每个用户进程对应m个内核级线程。</p><img src="\image\article\操作系统-进程管理\image-20220907215944571.png" alt="image-20220907215944571" style="zoom:80%;" /><p>克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</p><h3 id="总结用户线程和内核线程"><a href="#总结用户线程和内核线程" class="headerlink" title="总结用户线程和内核线程"></a>总结用户线程和内核线程</h3><ul><li><p>用户线程：</p><p><font color="red">即使多核CPU，多线程也不能并行执行。</font></p><ul><li>优点：<ul><li>每个进程都需要有它私有的线程控制块（TCB）列表，用来跟踪记录它各个线程状态信息（PC、栈指针、寄存器），TCB 由用户级线程库函数来维护，可用于不支持线程技术的操作系统；</li><li>用户线程的切换也是由线程库函数来完成的，无需用户态与内核态的切换，所以速度特别快；</li></ul></li><li>缺点：<ul><li>由于操作系统不参与线程的调度，如果一个线程发起了系统调用而阻塞，那进程所包含的用户线程都不能执行了。<font color="green">【<strong>一个阻塞，全部阻塞】</strong></font></li><li>当一个线程开始运行后，除非它主动地交出 CPU 的使用权，否则它所在的进程当中的其他线程无法运行，因为用户态的线程没法打断当前运行中的线程，它没有这个特权，只有操作系统才有，但是用户线程不是由操作系统管理的【无法中断线程运行】</li><li>由于时间片分配给进程，故与其他进程比，在多线程执行时，每个线程得到的时间片较少，执行会比较慢；</li></ul></li></ul></li><li><p>内核线程：</p><p><font color="red">在多核CPU中，多线程可以并行执行。</font></p><ul><li>优点：<ul><li>在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的运行；<font color="green"><strong>【一个阻塞，其他不影响】</strong></font></li><li>分配给线程，多线程的进程获得更多的 CPU 运行时间；</li></ul></li><li>缺点：<ul><li>在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息，如 PCB 和 TCB；</li><li>线程的创建、终止和切换都是通过系统调用的方式来进行，因此对于系统来说，系统开销比较大；【内核态和用户态需要进行转换。】</li></ul></li></ul></li></ul><p>参考：</p><p><a href="https://xiaolincoding.com/os/4_process/process_base.html">https://xiaolincoding.com/os/4_process/process_base.html</a></p><p>王道操作系统</p><p><a href="https://zhuanlan.zhihu.com/p/87272557">用户级线程和内核级线程，你分得清吗？ - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    <summary type="html">进程的定义，进程的状态及转换，进程控制，进程通信，以及多线程模型。</summary>
    
    
    
    <category term="操作系统" scheme="http://example.com/category/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="进程管理" scheme="http://example.com/tag/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>HashMap&amp;HashSet源码分析</title>
    <link href="http://example.com/post/a748c2b9.html"/>
    <id>http://example.com/post/a748c2b9.html</id>
    <published>2022-09-02T06:35:39.000Z</published>
    <updated>2022-09-02T14:15:04.234Z</updated>
    
    <content type="html"><![CDATA[<p>HashMap 主要用来存放键值对，它基于哈希表的 Map 接口实现，是常用的 Java 集合之一，是非线程安全的。</p><p><code>HashMap</code> 可以<font color="red"><strong>存储 null 的 key 和 value</strong></font></p><ul><li>null 作为键只能有一个</li><li>null 作为值可以有多个</li></ul><h1 id="JDK1-8之前的HashMap"><a href="#JDK1-8之前的HashMap" class="headerlink" title="JDK1.8之前的HashMap"></a>JDK1.8之前的HashMap</h1><p>JDK1.8之前的HashMap的底层是<strong>数组＋链表</strong>，数组是 HashMap 的主体，链表是用来解决冲突。（也就是所谓的“拉链法”）</p><ol><li><font color="blue"><strong>【获取hash值】</strong></font>HashMap通过key的hashCode经过扰动函数处理后得到<strong>hash值</strong></li><li><font color="blue"><strong>【找到存放位置】</strong></font>通过<code>(n-1)&amp;hash</code>获取当前元素当前存放位置（这里的 n 指的是数组的长度）。</li><li><font color="blue"><strong>【判断冲突】</strong></font>如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同【其实就是比较hash值以及使用key的equals方法。】<ul><li>如果相同的话，直接覆盖</li><li>不相同就通过拉链法解决冲突。</li></ul></li></ol><p>拉链法是一种解决冲突的方法，当发生冲突的时候，就创建一个节点，将该节点放在链表最后面</p><img src="\image\article\HashMap源码分析\image-20220902144906058.png" alt="image-20220902144906058" style="zoom: 67%;" /><p>扰动函数hash</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line"></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JDK1-8的HashMap"><a href="#JDK1-8的HashMap" class="headerlink" title="JDK1.8的HashMap"></a>JDK1.8的HashMap</h1><p>JDK1.8 以后在解决哈希冲突时有了较大的变化。</p><p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 <strong>数组+链表+红黑树</strong> 组成。【Java7是 <strong>数组＋链表</strong>】</p><blockquote><p>为什么要添加<strong>红黑树结构</strong>?</p><p>Java7的不足：</p><p>当我们进行查找时，根据 hash 值我们能够快速定位到数组的具体下标。</p><p>但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的。</p><p>时间复杂度取决于链表的长度，为 **O(n)**。</p><p>Java8的改进：</p><p>在 Java8 中，为了降低这部分的开销，<font color="red">当链表中的元素达到了 8 个时，会将链表转换为红黑树</font>。</p><p>在这些位置进行查找的时候可以降低时间复杂度为 **O(logN)**。</p></blockquote><p><font size=4>HashMap结构示意图【主要是描述结构，不会达到这个状态的，因为这么多数据的时候早就扩容了】</font></p><img src="\image\article\HashMap源码分析\image-20220902152819331.png" alt="image-20220902152819331" style="zoom:67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable</span><br></pre></td></tr></table></figure><h2 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// 默认初始容量  16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;  <span class="comment">//最大容量 2^30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>; <span class="comment">//默认装填因子 0.75</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;<span class="comment">// 链表转换为红黑树的阈值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;<span class="comment">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;<span class="comment">//桶中结构转化为红黑树对应的table的最小容量</span></span><br><span class="line"><span class="comment">// 加载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line"><span class="comment">// 临界值(容量*填充因子) 当实际大小超过临界值时，会进行扩容</span></span><br><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"><span class="comment">// 存放元素的个数，注意这个不等于数组的长度。</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size</span><br></pre></td></tr></table></figure><h3 id="装填因子LOAD-FACTOR"><a href="#装填因子LOAD-FACTOR" class="headerlink" title="装填因子LOAD_FACTOR"></a>装填因子LOAD_FACTOR</h3><p>什么是装填因子？$ a &#x3D; \frac{n}{m}$</p><p>n为哈希表的关键字个数，也就是哈希表中已经有多少个位置有元素了。</p><p>m表示哈希表的长度，也就是容量。</p><ul><li>loadFactor 越趋近于 1，那么 数组中存放的数据(entry)也就越多，也就越密<ul><li><strong>loadFactor 太大导致查找元素效率低，而且很容易导致冲突</strong></li></ul></li><li>loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。<ul><li><strong>太小导致数组的利用率低，存放的数据会很分散</strong></li></ul></li></ul><p>**loadFactor 的默认值为 0.75f 是官方给出的一个比较好的<font color="red">临界值</font>**。</p><blockquote><p>默认情况下，默认容量为 16，负载因子为 0.75。</p><p>Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 &#x3D; 12 个时。</p><p>就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 <strong>rehash、复制数据</strong>等操作，所以非常消耗性能。</p></blockquote><h3 id="threshold"><a href="#threshold" class="headerlink" title="threshold"></a>threshold</h3><p><strong>threshold &#x3D; capacity * loadFactor</strong>，<strong>当 Size&gt;&#x3D;threshold</strong>的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 <strong>衡量数组是否需要扩增的一个标准</strong>。</p><p>也就是这个size，你向map中添加元素的个数，并不是数组的长度【容量】。</p><h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存储元素的数组，总是2的幂次倍</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">//存放具体元素的集  键值对集合</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br></pre></td></tr></table></figure><p><strong><font size=4><code>Node&lt;K,V&gt;</code>链表节点内部类，源码如下</font></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash; <span class="comment">//哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span></span><br><span class="line">    <span class="keyword">final</span> K key;<span class="comment">//键</span></span><br><span class="line">    V value;<span class="comment">//值</span></span><br><span class="line">    Node&lt;K,V&gt; next; <span class="comment">//类似指针，指向下一个节点</span></span><br><span class="line"></span><br><span class="line">    Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.hash = hash;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span>        &#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span>      &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象结构如下：</p><p><img src="/%5Cimage%5Carticle%5CHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%5Cimage-20220902155602516.png" alt="image-20220902155602516"></p><p><font size=4><strong><code>TreeNode&lt;K,V&gt;</code>红黑树节点内部类</strong></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// 指向父亲</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;<span class="comment">//左孩子</span></span><br><span class="line">    TreeNode&lt;K,V&gt; right;<span class="comment">//右孩子</span></span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="type">boolean</span> red;<span class="comment">//判断颜色</span></span><br><span class="line">    TreeNode(<span class="type">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 返回根节点</span></span><br><span class="line">    <span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">root</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="built_in">this</span>, p;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((p = r.parent) == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            r = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略了大量代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><ul><li><p>无参构造，装填因子为默认的装填因子【0.75】,所有属性均为默认</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// 所有其他字段均为默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>包含另一个“Map”的构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;<span class="comment">//默认装填因子 0.75</span></span><br><span class="line">    putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部调用了<code>putMapEntries</code>方法【这个方法在后面讲】</p></li><li><p>指定“容量大小”的构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>指定“容量大小”和“加载因子”的构造函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="comment">//----------------判断参数是否合法-------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="comment">//----------------判断参数是否合法-------------------------------</span></span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);<span class="comment">//返回给定目标容量的2次方大小。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="putMapEntries方法"><a href="#putMapEntries方法" class="headerlink" title="putMapEntries方法"></a><code>putMapEntries</code>方法</h2><p>从一个Map对象中批量添加的函数。</p><p>这个方法服务于 <font color="red">Map的构造方法<code>HashMap(Map&lt;? extends K, ? extends V&gt; m)</code></font>和<font color="red">Map的<code>putAll(Map&lt;? extends K, ? extends V&gt; m)</code>方法</font>。</p><ul><li><p>当构造方法调用这个方法，**<font color="blue">evict为False</font>**</p></li><li><p>当putAll调用这个方法，**<font color="blue">evict为True</font>**</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> m.size(); <span class="comment">//获取传入map集合的大小</span></span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table == <span class="literal">null</span>) &#123; <span class="comment">// 判断table是否已经初始化  “自身的map&quot;</span></span><br><span class="line">            <span class="comment">//======================================================================</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> ((<span class="type">float</span>)s / loadFactor) + <span class="number">1.0F</span>;<span class="comment">//[ft = 元素个数/装填因子 +1 ]</span></span><br><span class="line">            <span class="comment">//计算 容量， [装填因子=元素个数/容量]。这个ft应该是预计需要多少容量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> ((ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY) ?<span class="comment">//如果ft&lt;最大容量，则t = ft,否则 t = 最大容量。</span></span><br><span class="line">                     (<span class="type">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">//======================================================================</span></span><br><span class="line">            <span class="comment">//总之通过以上计算，最后得到的这个t 表示，如果批量加入 这个Map，【最终预计需要多少容量】。</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)<span class="comment">//计算得到的t大于阈值，则初始化阈值,</span></span><br><span class="line">                threshold = tableSizeFor(t);<span class="comment">//tableSizeFor(t)  返回给定目标容量的2次方大小。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)<span class="comment">//判断 即将要加入的元素个数是否会大于阈值</span></span><br><span class="line">            resize();<span class="comment">//扩容</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet()) &#123;</span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tableSizeFor(t)</code>返回给定目标容量的2次方大小，比如 t &#x3D; 10，就返回16；t&#x3D;100，返回128。</p><p>流程总结：</p><ol><li><p>首先判断自身的<code>Node&lt;K,V&gt;[] table</code>有没有初始化</p><ul><li><p>如果没有初始化</p><p>​1.根据<font color="blue">传入Map所含元素数量，装填因子，最大容量</font>，来计算预计最终所需容量，<strong>t</strong>。</p><p>​2.如果t&gt;阈值，则阈值就是大于t的二次方大小。</p></li><li><p>如果初始化过，且 传入Map所含元素数量 s 大于 阈值，则对Map进行扩容。</p></li></ul></li><li><p>最后再循环遍历传入的Map，调用<code>putVal()</code>方法添加。</p></li></ol><blockquote><p>注：</p><ul><li><code>if (t &gt; threshold)</code>这里的<font color="red">threshold成员实际存放的值是capacity的值</font>。因为在table还没有初始化时（table还是null），用户给定的capacity会暂存到threshold成员上去（毕竟HashMap没有一个成员叫做capacity，<font color="red">capacity是作为table数组的大小而隐式存在的</font>）</li><li><code>else if (s &gt; threshold)</code>说明传入<strong>map</strong>的<strong>size</strong>都已经大于当前<strong>map</strong>的<strong>threshold</strong>了，即当前map肯定是装不下<font color="red">两个map的并集的</font>，所以这里必须要执行**<code>resize()</code>[扩容]**操作</li><li><code>putval</code>也是使用的默认修饰符，因此只能被本类或者该包下的类访问到，最后循环里的<font color="red"><code>putVal</code>可能也会触发resize操作</font></li></ul></blockquote><h2 id="put-方法-amp-putVal-方法"><a href="#put-方法-amp-putVal-方法" class="headerlink" title="put()方法&amp;putVal()方法"></a><code>put()</code>方法&amp;<code>putVal()</code>方法</h2><p>HashMap 只提供了 put 用于添加元素，putVal 方法只是给 put 方法调用的一个方法，并没有提供给用户使用。</p><p><code>put()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部调用了<code>putVal()</code>方法</p><p>参数：</p><ul><li>hash：key的hash值</li><li>key: 键</li><li>value：值</li><li>onlyIfAbsent：如果为真，不更改现有值</li><li>Evict ：如果为false，表示表处于创建模式。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,<span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)<span class="comment">//如果插入所要插入的位置 为 null，则直接插入。</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//判断hash和equal看是否等价。</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;<span class="comment">//等价就直接覆盖</span></span><br><span class="line">        <span class="comment">//不等价就判断是否是树节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);<span class="comment">//如果是就添加树节点</span></span><br><span class="line">        <span class="comment">//不等价，且不是树节点，就一定是链表节点。</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//遍历链表，添加到链表尾部。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//中间如果遇到等价元素就不用添加到尾部。</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// 值覆盖</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)<span class="comment">//如果元素个数大于阈值，就进行扩容。</span></span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>如果定位到的数组位置没有元素 就直接插入</li><li>如果定位到的数组位置有元素就和要插入的 key <font color="red">比较【比较hash和调用<code>equals()</code>】</font><ol><li>如果 key 相同就直接覆盖</li><li>如果 key 不相同<ol><li>如果是一个树节点就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>将元素添加进入</li><li>如果是链表节点就遍历链表插入(插入的是链表尾部)。</li></ol></li></ol></li></ol><blockquote><p><strong><font color="red">当链表长度大于阈值（默认为 8）并且 HashMap 数组长度超过 64 的时候才会执行链表转红黑树的操作，否则就只是对数组扩容。</font></strong></p><p>参考 HashMap 的 <code>treeifyBin()</code> 方法</p></blockquote><h2 id="扩容方法"><a href="#扩容方法" class="headerlink" title="扩容方法"></a>扩容方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;<span class="comment">//旧的数组 Table</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;<span class="comment">//旧的容量，即oldTab.length,如果非null,否则是0</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;<span class="comment">//旧的阈值</span></span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;<span class="comment">//初始  新的阈值和新的容量  为0</span></span><br><span class="line"><span class="comment">//===================================确定新的容量和新的阈值============================</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<span class="comment">//原本的容量达到 最大容量</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;<span class="comment">//那阈值就是int 最大值</span></span><br><span class="line">            <span class="keyword">return</span> oldTab;<span class="comment">//超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新的容量扩充为旧的两倍   ，而且没有超过规定的容量上限，且，旧的容量大于默认容量。   </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// 新的阈值也扩充为两倍</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//数组table没有初始，但有初始的阈值，那么新的容量就是阈值。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 初始容量置于阈值</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">//数组table没有初始化，且阈值也没有初始化</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// 零初始阈值表示使用默认值</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;<span class="comment">//新的容量就是默认容量</span></span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<span class="comment">//新的阈值就是 默认容量*默认装填因子。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果新的容量超过了MAXIMUM_CAPACITY，或者旧的容量小于 DEFAULT_INITIAL_CAPACITY【默认初始容量】</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;<span class="comment">//装填因子*新的容量</span></span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);  </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//===================================确定新的容量和新的阈值============================</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];<span class="comment">//初始一个新的数组</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 开始遍历原数组，进行数据迁移。  下面的有些无关紧要了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 如果该数组位置上只有单个元素，那就简单了，简单迁移这个元素就可以了</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下是如何扩容的</p><p><strong><font size=5>当你进行初始化时：</font></strong></p><ul><li><p>如果你是无参构造一个<code>HashMap</code></p><p>初始容量就是16（默认容量），初始阈值就是12（默认容量*默认装填因子）。</p></li><li><p>如果你使用初始容量的那个构造函数 new 一个HashMap</p><p>初始阈值就是 你指定的初始容量的2次方大小，初始容量就是初始阈值。</p><p>例如，<code>new HashMap&lt;&gt;(24);</code>，则初始容量为36，初始阈值也是36。</p></li></ul><p><strong><font size=5>当你添加的元素需要扩容时：</font></strong></p><ul><li><p>如果旧的容量小于最大容量【2^30】</p><ul><li><p>新的容量 为 旧的容量两倍，新的阈值因情况而定</p><ul><li><p>旧的容量 &gt; 默认容量【16】，且新的容量&lt;最大容量【2^30】：新的阈值 就是  旧的阈值两倍</p></li><li><p>旧的容量大于默认容量，且新的容量大于最大容量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;<span class="comment">//装填因子*新的容量</span></span><br><span class="line">newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY?(<span class="type">int</span>)ft:Integer.MAX_VALUE);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>如果旧的容量大于最大容量【2^30】</p><p>那阈值就是int 最大值，然后就不会再去扩充。</p></li></ul><blockquote><p>我们会发现，hashmap的容量总是2的次方，比如8、16、32、64…..</p><p>还有就是，在扩容的过程中它还需要进行数据迁移，这是非常耗时的，所以我们应该尽量避免扩容！</p></blockquote><h1 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h1><p><em>HashSet</em>是对<em>HashMap</em>的简单包装，对<em>HashSet</em>的函数调用都会转换成合适的<em>HashMap</em>方法，因此<em>HashSet</em>的实现非常简单，只有不到300行代码。这里不再赘述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">5024744406713321676L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//对HashMap的包装。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(Math.max((<span class="type">int</span>) (c.size()/<span class="number">.75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HashSet(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">boolean</span> dummy) &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.keySet().iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">重点需要理解的是HashMap的存放过程以及扩容机制。而HashSet是HashMap的封装，也就是说HashSet底层就是HashMap的底层。</summary>
    
    
    
    <category term="java基础" scheme="http://example.com/category/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="源码解析" scheme="http://example.com/tag/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList源码解析</title>
    <link href="http://example.com/post/abb154f4.html"/>
    <id>http://example.com/post/abb154f4.html</id>
    <published>2022-09-01T07:33:35.000Z</published>
    <updated>2022-09-02T14:14:24.083Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>声明：我用的Java的版本是<code>Java9</code>版本。版本不同，源代码也有差异。</p><p>ArrayList源码中大量使用了一下两个函数，首先搞清楚这两个函数的含义</p><ul><li><font size=5><code>System.arraycopy()</code></font></li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们发现 arraycopy 是一个 native 方法,接下来我们解释一下各个参数的具体意义</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   复制数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> src 源数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> srcPos 源数组中的起始位置</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> dest 目标数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> destPos 目标数组中的起始位置</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> length 要复制的数组元素的数量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">arraycopy</span><span class="params">(Object src,  <span class="type">int</span>  srcPos,</span></span><br><span class="line"><span class="params">                                    Object dest, <span class="type">int</span> destPos,</span></span><br><span class="line"><span class="params">                                    <span class="type">int</span> length)</span>;</span><br></pre></td></tr></table></figure><p> 举例：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">10</span>,<span class="number">23</span>,<span class="number">24</span>,<span class="number">15</span>,<span class="number">12</span>,<span class="number">45</span>,<span class="number">23</span>,<span class="number">56</span>,<span class="number">12</span>&#125;;</span><br><span class="line">System.arraycopy(array,<span class="number">5</span>,array,<span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line">System.out.println(Arrays.toString(array));<span class="comment">//[10, 23, 24, 15, 45, 23, 56, 12, 12]</span></span><br></pre></td></tr></table></figure><p> 含义：将<code>array</code>数组的元素，从下标<code>5</code>为起始，4个元素，赋给<code>array</code>数组从<code>4</code>索引开始的位置上。这个实现的是一个<strong>数组删除操作</strong>。</p><p> <img src="/image/article/ArrayList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/image-20220901170637925.png" alt="image-20220901170637925"></p><ul><li><font size=5><code>Arrays.copyOf()</code></font></li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] copyOf(<span class="type">int</span>[] original, <span class="type">int</span> newLength) &#123;</span><br><span class="line"><span class="comment">// 申请一个新的数组</span></span><br><span class="line">    <span class="type">int</span>[] copy = <span class="keyword">new</span> <span class="title class_">int</span>[newLength];</span><br><span class="line"><span class="comment">// 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组</span></span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                     Math.min(original.length, newLength));</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 含义是：传入原始数组，复制出一个<code>newLength</code>长度的数组。</p></blockquote><p><code>ArrayList</code>底层实现是<strong>数组</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><p><code>ArrayList</code>继承于 <strong><code>AbstractList</code></strong> ，实现了 <strong><code>List</code></strong>, <strong><code>RandomAccess</code></strong>, <strong><code>Cloneable</code></strong>, **<code>java.io.Serializable</code>**。</p><ul><li><code>RandomAccess</code> 是一个标志接口，表明实现这个这个接口的 List 集合是支持<strong>快速随机访问</strong>的。在 <code>ArrayList</code> 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</li><li><code>ArrayList</code> 实现了 <strong><code>Cloneable</code> 接口</strong> ，即覆盖了函数<code>clone()</code>，能被克隆。</li><li><code>ArrayList</code> 实现了 <code>java.io.Serializable</code>接口，这意味着<code>ArrayList</code>支持序列化，能通过序列化去传输。</li></ul><h1 id="ArrayList成员变量"><a href="#ArrayList成员变量" class="headerlink" title="ArrayList成员变量"></a>ArrayList成员变量</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br></pre></td></tr></table></figure><ul><li><code>DEFAULT_CAPACITY</code>定义了<code>ArrayList</code>的默认容量为 10。</li><li><code>MAX_ARRAY_SIZE</code>要分配的数组的最大大小。</li><li><code>EMPTY_ELEMENTDATA</code>和 <code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>都定义了一个空数组。<ul><li><code>EMPTY_ELEMENTDATA = &#123;&#125;</code>：空数组（用于空实例）</li><li><code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;</code>：<ul><li>用于默认大小空实例的共享空数组实例</li><li>把它从<code>EMPTY_ELEMENTDATA</code>数组中区分出来，用来知道在添加第一个元素时容量需要增加多少。</li></ul></li></ul></li><li><code>elementData</code>是<code>ArrayList</code>的底层实现，是一个Object数组。</li><li><code>size</code>表明<code>ArrayList</code>当前存有多少元素。</li></ul><h1 id="ArrayList构造方法"><a href="#ArrayList构造方法" class="headerlink" title="ArrayList构造方法"></a>ArrayList构造方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>ArrayList()</code></p><p>无参构造，将之前<font color="blue">已经初始化的默认实例[<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>]</font>赋值给<code>elementData</code></p><p>初始时容量为0， 当添加第一个元素的时候数组容量才变成10</p></li><li><p><code>ArrayList(int initialCapacity)</code></p><ul><li>带初始容量参数的构造函数（用户可以在创建<code>ArrayList</code>对象时自己指定集合的初始大小）<ol><li>如果<code>initialCapacity</code>大于0，就<code>new</code>一个Object数组。</li><li>如果<code>initialCapacity</code>等于0，将被赋值一个<font color="blue">空实例<code>EMPTY_ELEMENTDATA</code></font></li><li>如果<code>initialCapacity</code>小于0，抛出<code>IllegalArgumentException</code>异常。</li></ol></li></ul></li><li><p><code>ArrayList(Collection&lt;? extends E&gt; c)</code></p><ul><li><p>构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。</p><ol><li><p>首先将传入的集合转化为数组，赋值给<code>elementData</code></p></li><li><p>如果<code>elementData</code>的长度不为0</p><ul><li><p>如果<code>elementData</code>的类型不是<code>Object[]</code>类型。<code>c.toArray</code>可能返回的不是Object类型的数组</p><p>将原来不是Object类型的<code>elementData</code>数组的内容，赋值给新的Object类型的<code>elementData</code>数组</p></li></ul></li><li><p>如果<code>elementData</code>的长度为0</p><p><code>elementData</code>被赋值为一个<font color="blue">空实例<code>EMPTY_ELEMENTDATA</code></font></p></li></ol></li></ul></li></ul><h1 id="ArrayList常用方法"><a href="#ArrayList常用方法" class="headerlink" title="ArrayList常用方法"></a>ArrayList常用方法</h1><p><code>ArrayList</code>的常用方法有：</p><ul><li><code>get()</code></li><li><code>add()</code></li><li><code>set()</code></li><li><code>remove()</code></li></ul><h2 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a><code>get()</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    Objects.checkIndex(index, size);</span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>首先他会检查这个索引是否合法</p></li><li><p>然后调用<code>elementData(index)</code>方法，返回元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E <span class="title function_">elementData</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];<span class="comment">//进行了强制转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="add-方法"><a href="#add-方法" class="headerlink" title="add()方法"></a><code>add()</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    add(e, elementData, size);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了<code>add(E e, Object[] elementData, int s)</code>方法，这是一个私有方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e, Object[] elementData, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == elementData.length)</span><br><span class="line">        elementData = grow();</span><br><span class="line">    elementData[s] = e;</span><br><span class="line">    size = s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是一个辅助方法，从add(E)中分离出来，以保持方法字节码大小小于35 。</p><p><code>E e</code>：表示要插入的元素</p><p><code>Object[] elementData</code>：表示要插入的数组</p><p><code>int s</code>表示要插入的位置</p><ol><li>首先判断，<code>elementData</code>是否已满，如果已经满了，再调用<code>grow()</code>方法进行扩容。</li><li>然后就是数组赋值操作了。</li></ol><h2 id="set-方法"><a href="#set-方法" class="headerlink" title="set()方法"></a><code>set()</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    Objects.checkIndex(index, size);</span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先他会检查这个索引是否合法</li><li>然后获取该索引位置原始元素</li><li>该索引位置被新元素所取代</li><li>返回旧元素</li></ol><h2 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove()方法"></a><code>remove()</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    Objects.checkIndex(index, size);<span class="comment">//检查索引</span></span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);<span class="comment">//获取原始元素</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要将删除点之后的元素向前移动一个位置。</p><p>需要注意的是：为了让<code>GC</code>起作用，必须将最后一个元素置为null。</p><p>对象能否被<code>GC</code>的依据是<strong>是否还有引用指向它</strong>，上面代码中如果不手动赋<code>null</code>值，除非对应的位置被其他元素覆盖，否则原来的对象就一直不会被回收。</p><h1 id="ArrayList的扩容策略"><a href="#ArrayList的扩容策略" class="headerlink" title="ArrayList的扩容策略"></a>ArrayList的扩容策略</h1><p>一步一步的看<code>ArrayList</code>的扩容策略，扩容函数是<code>grow()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object[] grow() &#123;</span><br><span class="line">    <span class="keyword">return</span> grow(size + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部又调用了<code>grow(size + 1)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object[] grow(<span class="type">int</span> minCapacity) &#123;</span><br><span class="line">    <span class="type">return</span> <span class="variable">elementData</span> <span class="operator">=</span> Arrays.copyOf(elementData,</span><br><span class="line">                                       newCapacity(minCapacity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加容量以确保它至少能容纳最小容量参数指定的元素数量。<br>参数:<br><code>minCapacity</code>—期望的最小容量</p><p>返回一个从原始数组<code>elementData</code>，复制一个容量为<code>newCapacity(minCapacity)</code>是数组。从而进行扩容。</p><p>这个<code>newCapacity(minCapacity)</code>返回新的容量。<code>newCapacity()</code>是扩容的核心。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">newCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (newCapacity - MAX_ARRAY_SIZE &lt;= <span class="number">0</span>)</span><br><span class="line">        ? newCapacity</span><br><span class="line">        : hugeCapacity(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code> int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</code>表明新的容量是旧的容量的1.5倍。</p><ul><li><p>如果<font color="blue">新的容量</font>小于等于<font color="blue">期望的最小容量</font>：</p><ol><li><p>如果此时<code>ArrayList</code>的底层数组<code>elementData</code>是<font color="red">默认的空实例<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code></font>：</p><p>则<code>ArrayList</code>至少扩容为默认容量10。<code>Math.max(10, minCapacity)</code></p></li><li><p>如果不是默认的空实例，但期望的最小容量小于0，就抛出异常。</p></li><li><p>如果以上两种情况都不符合，就返回期望的最小容量。然后<code>ArrayList</code>就会扩容为期望的最小容量。</p></li></ol></li><li><p>如果<font color="blue">新的容量</font>大于<font color="blue">期望的最小容量</font>：</p><p>检查这新的容量，是否小于，允许扩容的最大容量【<code>Integer.MAX_VALUE - 8</code>】。</p><ul><li><p>如果小于，则返回<font color="blue">新的容量</font>，即<code>ArrayList</code>将扩容为旧容量的1.5倍。</p></li><li><p>如果大于，则调用<code>hugeCapacity(minCapacity)</code>函数，在对<font color="blue">期望的最小容量</font>进行进步判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE)</span><br><span class="line">        ? Integer.MAX_VALUE</span><br><span class="line">        : MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果<font color="blue">期望的最小容量</font>大于<strong>允许扩容的最大容量</strong>，则<code>ArrayList</code>扩容为int整数的最大值。</li><li>否则<code>ArrayList</code>扩容为<strong>允许扩容的最大容量</strong></li></ul></li></ul><blockquote><p>扩容策略总结：</p><ul><li>默认容量：10</li><li>最大扩容容量：<code>Integer.MAX_VALUE - 8 = 2147483639</code></li><li>最小期望容量：当前容量+1</li></ul><p>当添加第一个元素时，任何带有<code>elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>的空数组列表将被扩展为<code>DEFAULT_CAPACITY</code>。</p><p>即</p><ol><li><p>如果<code>ArrayList</code>使用无参构造初始化，初次添加元素，会扩容为10。</p></li><li><p>其他情况，当需要扩容时</p><p><code>minCapacity</code>最小期望容量为当前容量+1。</p><ul><li><p><font color="red">如果<code>minCapacity</code>&lt;10，就会扩容为最小期望容量</font></p></li><li><p>如果<code>minCapacity</code>&gt;10，新容量为原始容量的1.5倍。</p><ul><li><font color="red">如果这个新的容量小于允许最大容量，则扩容为原始容量的1.5倍。</font></li><li>如果这个新的容量大于允许最大容量<ul><li><font color="red">最小期望容量小于允许最大容量，则扩容为，允许的最大容量</font></li><li><font color="red">最小期望容量小于允许最大容量，则扩容为，int整型的最大值。</font></li></ul></li></ul></li></ul></li></ol></blockquote></li></ul><h1 id="并发修改异常"><a href="#并发修改异常" class="headerlink" title="并发修改异常"></a>并发修改异常</h1><p>并发修改异常是发生在<code>ArrayList</code>使用<strong>迭代器</strong>遍历过程中，对<code>ArrayList</code>进行修改而发生的异常。</p><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">        arrayList.add(<span class="number">10</span>);arrayList.add(<span class="number">23</span>);arrayList.add(<span class="number">17</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : arrayList) &#123;</span><br><span class="line">            <span class="keyword">if</span>(integer%<span class="number">5</span>==<span class="number">0</span>)arrayList.add(<span class="number">21</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(arrayList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引发异常<code>ConcurrentModificationException</code>。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>我们知道增强式for循环，它本质是使用迭代器。</p><p><code>ArrayList</code> 继承了<code>AbstractList</code>抽象类，它里面定义了一个变量<code>modCount</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span>  AbstractList&lt;E&gt;&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//跟进父类  初试为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>modCount</code>表示预期修改次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();<span class="comment">//获取迭代器。</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;<span class="comment">//预期集合修改次数</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            modCount:实际集合修改次数</span></span><br><span class="line"><span class="comment">            expectedModCount:预期集合修改次数</span></span><br><span class="line"><span class="comment">        */</span>    </span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;           </span><br><span class="line">            checkForComodification();           </span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;             </span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size)    </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">            Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length)    </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();  </span><br><span class="line">            cursor = i + <span class="number">1</span>;     </span><br><span class="line">            <span class="keyword">return</span> (E) elementData[lastRet = i];  </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;  </span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)<span class="comment">//不一样了，抛出异常 </span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123; </span><br><span class="line">        modCount++;<span class="comment">//实际操作次数++,预期的并没有++ </span></span><br><span class="line">        add(e, elementData, size); </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们通过<code>iterator()</code>方法获取迭代器，<code>expectedModCount = modCount</code>此时<font color="red">预期修改次数</font>和<font color="red">实际修改次数</font>相等。</p><p>当调用迭代器的<code>next()</code>方法时，每次调用都会检查<font color="red">预期修改次数</font>和<font color="red">实际修改次数</font>是否相等，如果不相等就会抛出异常。</p><p>而，我们调用<code>add()</code>方法时，<code>modCount++</code>，<font color="red">实际修改次数</font>加一，但预期修改次数不变。等下次调用next()的时候，就会引发并发修改异常。</p><p>除了<code>add()</code>方法，一下方法，在迭代器遍历过程中调用也会产生并发修改异常，因为它们内部也同样<code>modCount++</code>：</p><ul><li><code>trimToSize()</code></li><li><code>ensureCapacity()</code></li><li><code>remove()</code></li><li><code>clear()</code></li><li><code>addAll()</code></li><li><code>removeRange()</code></li><li><code>batchRemove()</code></li></ul><p>…….</p><h1 id="附-查看集合容量的方法"><a href="#附-查看集合容量的方法" class="headerlink" title="附:查看集合容量的方法"></a>附:查看集合容量的方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看ArrayList集合容量方法 -- 反射</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getArrayListLength</span><span class="params">(ArrayList list)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//获取Class对象</span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.util.ArrayList&quot;</span>);</span><br><span class="line">    <span class="comment">//映射Class对象c所表示类(即Arraylist)的属性</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;elementData&quot;</span>);</span><br><span class="line">    <span class="comment">//设置访问状态表示为true</span></span><br><span class="line">    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//返回指定对象上此 Field 表示的字段的值</span></span><br><span class="line">    Object[] object = (Object[])field.get(list);</span><br><span class="line">    <span class="keyword">return</span> object.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">ArrayList常用方法的源码分析、ArrayList的扩容策略以及并发修改异常。</summary>
    
    
    
    <category term="java基础" scheme="http://example.com/category/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="源码解析" scheme="http://example.com/tag/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Java对象序列化和反序列化</title>
    <link href="http://example.com/post/20dbe6cd.html"/>
    <id>http://example.com/post/20dbe6cd.html</id>
    <published>2022-09-01T06:03:24.000Z</published>
    <updated>2022-09-01T07:19:49.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><font size=5><strong>对象序列化：</strong></font></p><p>所谓的对象序列化就是将对象保存到磁盘中，或者在网络中传输对象。</p><p>这种机制就是使用一个<strong>字节序列</strong>表示一个对象，该字节序列包含:</p><ul><li>对象的类型</li><li>对象的数据</li><li>对象中存储的属性等信息</li></ul><p>字节序列写到文件之后，相当于文件中持久保存了一个对象的信息</p><p><font size=5><strong>对象反序列化：</strong></font></p><p>对象反序列化就是将 对象的字节序列从文件中读取回来，重构对象，对它进行反序列化。</p><h1 id="对象序列化准备工作"><a href="#对象序列化准备工作" class="headerlink" title="对象序列化准备工作"></a>对象序列化准备工作</h1><h2 id="实现Serializable接口"><a href="#实现Serializable接口" class="headerlink" title="实现Serializable接口"></a>实现<code>Serializable</code>接口</h2><p>如果要将，对象序列化，该对象必须实现<code>Serializable</code>接口，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">42L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;  <span class="comment">//不想被序列化 transient</span></span><br><span class="line"><span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Serializable</code>接口表示该类 启用 <strong>类的序列化</strong>，也就是允许该类被序列化。该接口没有实现方法，只是一个标识性的接口。</p><p>如果需要序列化或者反序列化的类不实现该接口，那么在序列化或者序列化过程中抛出异常<code>NotSerializableException</code>。</p><h2 id="最好显式声明一个serialVersionUID"><a href="#最好显式声明一个serialVersionUID" class="headerlink" title="最好显式声明一个serialVersionUID"></a>最好显式声明一个<code>serialVersionUID</code></h2><blockquote><p>什么是<code>serialVersionUID</code>？</p><p>序列化运行时将<font color="blue"><strong>每个可序列化的类</strong></font>与<font color="blue"><strong>称为<code>serialVersionUID</code>的版本号</strong></font>相关联。</p><p>该序列号在反序列化期间<strong>用于验证序列化对象的发送者和接收者是否已加载与该序列化兼容的对象的类</strong>。  如果接收方加载了一个具有不同于相应发件人类的<code>serialVersionUID</code>的对象的类，则反序列化将导致<code>InvalidClassException</code> 。</p><p>简而言之：</p><p>相当于Java的版本号，保证<strong>序列化的对象</strong> 和 <strong>反序列化兼容的对象</strong> 的版本相同才能反序列化。</p></blockquote><p>如果没有显式地声明一个<code>serialVersionUID</code></p><p>则序列化运行时将根据**Java（TM）对象序列化规范中所述的类的<font color="blue">各个方面</font>**计算该类的默认<code>serialVersionUID</code>值</p><p>默认的<code>serialVersionUID</code>计算对类详细信息<font color="blue"><strong>非常敏感</strong></font>，这可能会<strong>因编译器实现</strong>而异，因此可能会在反<code>InvalidClassException</code>化期间导致<code>InvalidClassException</code>的<code>InvalidClassException</code>。</p><p>比如将如下类的对象序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;  </span><br><span class="line"><span class="comment">//Geter 和 Seter....省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在反序列化之前，<strong>修改这个类</strong>，添加一个属性或者删除一个属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;  </span><br><span class="line">    <span class="keyword">private</span> String address</span><br><span class="line"><span class="comment">//Geter 和 Seter....省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就会抛出<code>InvalidClassException</code>异常。异常信息：</p><p><code>stream classdesc serialVersionUID = 6500785223629970781, local class serialVersionUID = -4354424114631597798</code></p><p>异常信息表明，流对象发”版本号“是6500785223629970781，当前接收的类的”版本号“是-4354424114631597798。</p><p><font color="red"><strong>版本号不一致！</strong></font>这说明默认的<code>serialVersionUID </code>对类的细节非常敏感！</p><p>但如果我们显式的声明<code>serialVersionUID</code>就不会出现这种问题。需要说明的是，**<font color="red">该字段必须是静态的，最终的，类型是<code>long</code> </font>**</p><p><strong>显式声明一个<code>serialVersionUID</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">42L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;  </span><br><span class="line"><span class="comment">//Geter 和 Seter....省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他需要注意的"><a href="#其他需要注意的" class="headerlink" title="其他需要注意的"></a>其他需要注意的</h2><ul><li>序列化的类必须有<strong>可访问的无参构造函数</strong></li><li>序列化的类不能包含<strong>未知的数据类型</strong></li></ul><p>否则都会引发<code>InvalidClassException</code>异常。</p><p>如果你不想类中某个字段不被序列化，可以<font color="red">使用<code>transient</code>关键字修饰</font>。</p><h1 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h1><ul><li>对象序列化使用<code>objectOutputStream</code>类。<ul><li>方法：<code>void writeobject (object obj)</code>:将指定的对象写入<code>objectOutputStream</code></li></ul></li><li>反序列化使用<code>objectInputStream</code>类。<ul><li>方法：<code>object read0bject ()</code>:从<code>objectInputStream</code>读取一个对象</li></ul></li></ul><p>了解一下就行了，真正开发时，用的很少。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UID</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">write();</span><br><span class="line">        read();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">People</span> <span class="variable">peo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:\\oos.txt&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">        oos.writeObject(peo);</span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\oos.txt&quot;</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">        <span class="type">People</span> <span class="variable">people</span> <span class="operator">=</span> (People) object;</span><br><span class="line">        System.out.println(people.getName());</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">42L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> age;  <span class="comment">//不想被序列化 transient</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">People</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Serializable接口、为什么要显式声明一个serialVersionUID、transient关键字以及其他一些注意事项。</summary>
    
    
    
    <category term="java基础" scheme="http://example.com/category/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="序列化和反序列化" scheme="http://example.com/tag/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Sharding-jdbc分表配置</title>
    <link href="http://example.com/post/2afab64c.html"/>
    <id>http://example.com/post/2afab64c.html</id>
    <published>2022-08-29T14:49:04.000Z</published>
    <updated>2022-08-29T15:51:32.560Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做一个用Java实现一个简易的搜索引擎项目时，由于数据量很大，需要分表。这里的分表指的<strong>水平分表</strong>。数据大概有几千万行了吧。</p><p><img src="/%5Cimage%5Carticle%5CSharding-jdbc%E5%88%86%E8%A1%A8%E9%85%8D%E7%BD%AE%5Cimage-20220829225513347.png" alt="image-20220829225513347"></p><p>当数据量特别大的时候，查询速度特别慢，为了加快查询速度，只能采用分表的策略。除了水平切分还有垂直切分，用的不多。</p><p>当数据库分表后，为了方便操作数据库，我们可以采用<code>Sharding-jdbc</code>。你可以把它理解为加强版的<code>JDBC</code>。</p><p>当我们需要使用<code>Shard-jdbc</code>，首先我们需要导入<code>pom</code>坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sharding-jdbc-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0-RC1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我这里使用的<code>4.0</code>版本</p><p>然后配置如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">main:</span></span><br><span class="line">    <span class="attr">allow-bean-definition-overriding:</span> <span class="literal">true</span> <span class="comment">#允许bean覆盖</span></span><br><span class="line">  <span class="attr">shardingsphere:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">      <span class="attr">names:</span> <span class="string">master</span><span class="comment">#数据源名称</span></span><br><span class="line">      <span class="attr">master:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span>  <span class="comment">#使用druid数据源，如果不用就去掉这一行，如果用记得导入pom坐标</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://192.168.37.135:3306/my_search_engine?serverTimezone=UTC</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">sharding:</span> </span><br><span class="line">      <span class="attr">tables:</span></span><br><span class="line">        <span class="attr">data_seg_relation:</span> <span class="comment">#需要分表的表名  也可以理解为分表后的表名前缀</span></span><br><span class="line">        <span class="comment">#分成100个表 从data_seg_relation_0 --&gt;data_seg_relation_99</span></span><br><span class="line">          <span class="attr">actual-data-nodes:</span> <span class="string">master.data_seg_relation_$-&gt;&#123;0..99&#125;</span> </span><br><span class="line">          <span class="attr">key-generator:</span> <span class="comment">#主键生成策略</span></span><br><span class="line">            <span class="attr">column:</span> <span class="string">id</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">SNOWFLAKE</span>  <span class="comment">#使用雪花算法生成id</span></span><br><span class="line">          <span class="attr">table-strategy:</span></span><br><span class="line">            <span class="attr">inline:</span></span><br><span class="line">              <span class="attr">algorithm-expression:</span> <span class="string">data_seg_relation_$-&gt;&#123;seg_id</span> <span class="string">%</span> <span class="number">100</span><span class="string">&#125;</span> <span class="comment">#如何映射到表</span></span><br><span class="line">              <span class="attr">sharding-column:</span> <span class="string">seg_id</span></span><br></pre></td></tr></table></figure><p>说明一下，这是数据库里面的表。</p><p>我们可以看到  <code>data_seg_relation</code>被分成了100个表，从<code>data_seg_relation_0</code>到<code>data_seg_relation_99</code></p><img src="\image\article\Sharding-jdbc分表配置\image-20220829230552472.png" alt="image-20220829230552472" style="zoom: 80%;" /><p><font size=5><strong>表结构</strong></font></p><img src="\image\article\Sharding-jdbc分表配置\image-20220829230826244.png" alt="image-20220829230826244" style="zoom:80%;" /><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">algorithm-expression:</span> <span class="string">data_seg_relation_$-&gt;&#123;seg_id</span> <span class="string">%</span> <span class="number">100</span><span class="string">&#125;</span> <span class="comment">#如何映射到表</span></span><br><span class="line"><span class="attr">sharding-column:</span> <span class="string">seg_id</span></span><br></pre></td></tr></table></figure><p>这个配置的意思是，当你查询的时候，比如 <code>select * from data_seg_relation where seg_id=1165136</code>，</p><p><code>Shard-jdbc</code>会根据<code>seg_id</code>这个取值，<code>seg_id % 100 = 36</code>。然后它实际就会去查<code>data_seg_relation_36</code>这个表。</p><p><strong>当你配置好之后，你就可以像没有分表那样来去操作数据库。</strong></p><p>但需要注意的是【踩的几个坑吧】:</p><ul><li><p>如果你的<code>Java</code>是<code>jdk8</code>以上的版本，或许你会报这样的错：</p><p><code>Cause: javax.xml.bind.JAXBException: Implementation of JAXB-API has not been found on module path or classpath.</code></p><p>大概率就是你<code>jdk</code>版本的原因，要么你回退到<code>jdk8</code>版本，要么你就添加如下<code>pom</code>坐标。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/javax.activation/activation --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.activation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.glassfish.jaxb/jaxb-runtime --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.glassfish.jaxb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-runtime<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0-b170127.1453<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>当你用使用mybatis或mybatis-plus时，就不需要再配置它们的数据源了。</p></li><li><p>你当你写<code>SQL</code>时，最好别用子查询，因为你可能会报错的，【错误信息找不到ಥ_ಥ】</p><p>解决方法就是不用子查询，一条<code>SQL</code>语句拆成两条不就好了！</p></li></ul>]]></content>
    
    
    <summary type="html">SpringBoot整合Sharding-jdbc,并进行简单的分表。</summary>
    
    
    
    <category term="Spring" scheme="http://example.com/category/Spring/"/>
    
    
    <category term="分表" scheme="http://example.com/tag/%E5%88%86%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>前缀树</title>
    <link href="http://example.com/post/84520ef4.html"/>
    <id>http://example.com/post/84520ef4.html</id>
    <published>2022-08-28T11:35:48.000Z</published>
    <updated>2022-09-08T04:01:10.063Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前缀树简介"><a href="#前缀树简介" class="headerlink" title="前缀树简介"></a>前缀树简介</h1><p>又称单词查找树，字典树，<code>Trie</code>树，是一种树形结构，是一种<strong>哈希树</strong>的变种。</p><p>典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。</p><p>它的优点是：<code>利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高</code>。</p><p>是一种典型的用时间换空间的数据结构</p><p><strong>前缀树的性质：</strong></p><ul><li><font color="red"><strong>根节点不包含字符</strong></font>，除根节点外每一个节点都只包含一个字符</li><li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串</li><li>每个节点的所有子节点包含的字符都不相同</li></ul><p>假设有<code>b</code>，<code>abc</code>，<code>abd</code>，<code>bcd</code>，<code>abcd</code>，<code>efg</code>，<code>hii </code>这6个单词,那我们创建<code>trie</code>树就得到</p><p><img src="/%5Cimage%5Carticle%5C%E5%89%8D%E7%BC%80%E6%A0%91%5C20190924193658133.png" alt="20190924193658133"></p><p>其中红色的节点表示，从根节点到该节点连成的字符串，是前缀树包含的。</p><h1 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h1><p>定义<strong>前缀树节点</strong>的数据结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    Map&lt;Character,Node&gt; child;</span><br><span class="line">    <span class="type">boolean</span> isEnd;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span>&#123;</span><br><span class="line">        child = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<code>Map</code>来存储该节点的孩子节点</p><p>布尔类型的<code>isEnd</code>很重要，前缀树包含某一字符串，但该前缀树不一定存入该字符串。【如上图所示的红色节点】</p><p>它标识以该字符为结尾的字符串是存入的字符串。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tire.insert(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">tire.search(<span class="string">&quot;app&quot;</span>);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p><font size= 4><strong>前缀树的实现</strong></font></p><p><strong>字符串插入</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> root;<span class="comment">//指针指向根节点,从前缀树的根节点开始遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123;<span class="comment">//遍历该字符串</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(!node.child.containsKey(c))&#123;<span class="comment">//如果该节点的孩子节点不包含该字符</span></span><br><span class="line">            node.child.put(c,<span class="keyword">new</span> <span class="title class_">Node</span>());<span class="comment">//新加入该字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==word.length()-<span class="number">1</span>)node.child.get(c).isEnd=<span class="literal">true</span>;<span class="comment">//当到了最后的一个字符时，就标记为一个字符串的结尾。</span></span><br><span class="line">        node = node.child.get(c);<span class="comment">//指针指向孩子节点。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>字符串查找</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> root;<span class="comment">//指针指向根节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123;<span class="comment">//遍历该字符串</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">        <span class="comment">//如果存在某个节点的孩子不包含该字符串，就说明前缀树中不存在该字符串</span></span><br><span class="line">        <span class="keyword">if</span>(!node.child.containsKey(c))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        node = node.child.get(c);<span class="comment">//指针指向孩子节点。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.isEnd;<span class="comment">//都包含的还不行，还得看看该节点是否标记为字符串的结束标志</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>前缀树是否包含字符串的前缀</strong></p><p>和字符串代码唯一不同的是：</p><p>如果包含该字符串，最后<code>return</code>的时候，不会判断该节点是否标记为字符串结束标志。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> prefix.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(!node.child.containsKey(c))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        node = node.child.get(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>找到以某字符串为前缀的字符串</strong></p><p>例如：</p><p>前缀树包含的字符串有，<code>apple</code>、<code>code</code>、<code>appl</code>、<code>leet</code>、<code>apples</code>、<code>abc</code>、<code>ace</code></p><p>找到以<code>app</code>为前缀的字符们：<code>apple</code>、<code>appl</code>、<code>apples</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">searchprefix</span><span class="params">(String word)</span> &#123;</span><br><span class="line">    cnt = <span class="number">0</span>;   <span class="comment">//前缀字符串数量</span></span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> root;<span class="comment">//指针指向根节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length();i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (!node.child.containsKey(c)) <span class="keyword">return</span> res;<span class="comment">//如果不包含该前缀字符串直接return res</span></span><br><span class="line">        node = node.child.get(c);<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到前缀之后，以前缀末尾字符的节点开始进行深度优先遍历。</span></span><br><span class="line">    dfs(word, node, res, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(String word, Node node, List&lt;String&gt; res, String path)</span> &#123;  <span class="comment">// 深度优先搜索</span></span><br><span class="line">    <span class="keyword">if</span> (cnt &gt;= COUNT) <span class="keyword">return</span>;<span class="comment">//COUNT为要查找的前缀字符串数量</span></span><br><span class="line">    <span class="keyword">if</span> (node.isEnd &amp;&amp; !word.equals(word + path)) &#123;</span><br><span class="line">        res.add(word + path);</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Character, Node&gt; entry : node.child.entrySet()) &#123;</span><br><span class="line">        node = entry.getValue();</span><br><span class="line">        path = path + entry.getKey();</span><br><span class="line">        dfs(word, node, res, path);</span><br><span class="line">        path = path.substring(<span class="number">0</span>, path.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="完整Java代码"><a href="#完整Java代码" class="headerlink" title="完整Java代码"></a>完整Java代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">// 提示内容的最大数目</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        Map&lt;Character,Node&gt; child;</span><br><span class="line">        <span class="type">boolean</span> isEnd;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span>&#123;</span><br><span class="line">            child = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            isEnd = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node root;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(!node.child.containsKey(c))&#123;</span><br><span class="line">                node.child.put(c,<span class="keyword">new</span> <span class="title class_">Node</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i==word.length()-<span class="number">1</span>)node.child.get(c).isEnd=<span class="literal">true</span>;</span><br><span class="line">            node = node.child.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(!node.child.containsKey(c))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            node = node.child.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> prefix.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(!node.child.containsKey(c))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            node = node.child.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">searchprefix</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> root;    </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length();i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!node.child.containsKey(c)) <span class="keyword">return</span> res;</span><br><span class="line">            node = node.child.get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(word, node, res, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(String word, Node node, List&lt;String&gt; res, String path)</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= COUNT) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.isEnd &amp;&amp; !word.equals(word + path)) &#123;</span><br><span class="line">            res.add(word + path);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character, Node&gt; entry : node.child.entrySet()) &#123;</span><br><span class="line">            node = entry.getValue();</span><br><span class="line">            path = path + entry.getKey();</span><br><span class="line">            dfs(word, node, res, path);</span><br><span class="line">            path = path.substring(<span class="number">0</span>, path.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">前缀树的简介以及前缀树的Java实现。</summary>
    
    
    
    <category term="数据结构与leetcode算法" scheme="http://example.com/category/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8Eleetcode%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构" scheme="http://example.com/tag/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot跨域请求</title>
    <link href="http://example.com/post/1efeaa73.html"/>
    <id>http://example.com/post/1efeaa73.html</id>
    <published>2022-08-25T07:27:28.000Z</published>
    <updated>2022-08-25T10:22:29.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="跨域请求的概念"><a href="#跨域请求的概念" class="headerlink" title="跨域请求的概念"></a>跨域请求的概念</h1><p>浏览器出于安全的考虑，使用 <code>XMLHttpRequest</code>对象发起 HTTP请求时必须遵守同源策略，否则就是跨域的HTTP请求，<strong>默认情况下是被<font color="red">禁止</font>的</strong>。 </p><p><font color="red">同源策略</font>要求源相同才能正常进行通信，即<strong>协议、域名【或者是主机名】、端口号</strong>都完全一致。 </p><p>说通俗一点</p><ul><li>浏览器从一个域名的网页去请求另一个域名的资源时，<u>域名、端口、协议任一不同</u>，都是跨域</li><li>只要协议、域名、端口有任何一个不同，都被当作是不同的域，之间的请求就是跨域操作。</li></ul><p>例如：</p><table><thead><tr><th>前端</th><th>后端</th></tr></thead><tbody><tr><td><code>http://localost:8080</code></td><td><code>http://localhost:8081</code></td></tr></tbody></table><p>协议相同，主机名相同，但端口号不同。这就是跨域请求。</p><blockquote><p>注意</p><ul><li>只有浏览器才会有这个跨域请求的问题，如果是移动端跨域请求就不会出现问题。</li><li><code>XMLHttpRequest</code>对象就是<code>ajax</code>发送异步请求时使用的对象，所以也就是说浏览器使用<code>ajax</code>请求时才会出现跨域请求的问题。</li></ul><p>总得来说，发生跨域请求问题的场景就是：<strong>浏览器使用<code>ajax</code>请求</strong></p></blockquote><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>解决跨域请求有多种方案</p><p>我们可以使用<code>CORS</code>解决跨域。</p><h2 id="什么是CORS"><a href="#什么是CORS" class="headerlink" title="什么是CORS"></a>什么是<code>CORS</code></h2><p>​<code>CORS</code>是一个<code>W3C</code>标准，全称是”跨域资源共享”（Cross-origin resource sharing），允许浏览器向跨源服务器，发出<code>XMLHttpRequest</code>请求，从而克服了AJAX只能同源使用的限制。</p><p>​它通过服务器增加一个特殊的<code>Header[Access-Control-Allow-Origin]</code>来告诉客户端跨域的限制，如果浏览器支持<code>CORS</code>、并且判断Origin通过的话，就会允许<code>XMLHttpRequest</code>发起跨域请求。</p><p>如果是一个跨域请求，就会再发送一个带有<font color="red"><code>Origin</code></font>的请求头。里面的值就是<strong>这个页面所在的域</strong></p><p><img src="/%5Cimage%5Carticle%5CSpringBoot%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%5Cimage-20220825170142608.png" alt="image-20220825170142608"></p><p>发送给服务器之后，如果我们配置了跨域，响应头就会带有<font color="red"><code>Access-Control-Allow-Origin</code></font>，它的值表示<strong>服务器允许跨域的域</strong>，</p><p>如果该值和请求头的<code>Origin</code>值一样，则表示允许跨域。就会请求成功。</p><p><img src="/%5Cimage%5Carticle%5CSpringBoot%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%5Cimage-20220825170405785.png" alt="image-20220825170405785"></p><p>如果我们要自己使用<code>Cors</code>解决跨域请求的问题其实就是</p><p>解析请求头，然后去添加响应头就好了。但我们没必要自己去写，<code>SpringBoot</code>有这样的解决跨域请求的拦截器，只需要配置就可以。</p><blockquote><p>如果我们进行了<code>Cors</code>配置，但响应头中没有<code>Access-Control-Allow-Origin</code>，说明我们的配置是有问题的。</p></blockquote><h1 id="SpringBoot使用CORS解决跨域"><a href="#SpringBoot使用CORS解决跨域" class="headerlink" title="SpringBoot使用CORS解决跨域"></a>SpringBoot使用CORS解决跨域</h1><ul><li><p>使用<font color="gold"><code>@CrossOrigin</code></font></p><p>可以在支持跨域的<strong>方法</strong>上或者是<strong>Controller类</strong>上加上<font color="gold"><code>@CrossOrigin</code></font>注解</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="meta">@CrossOrigin</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserServcie userServcie;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/findAll&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseResult <span class="title function_">findAll</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//调用service查询数据 ，进行返回</span></span><br><span class="line">        List&lt;User&gt; users = userServcie.findAll();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseResult</span>(<span class="number">200</span>,users);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>value</code>属性可以设置多个URL。</p></li><li><p><code>origins</code>属性也可以设置多个URL。例如：<code>@CrossOrigin(origins = &quot;http://domain2.com&quot;, maxAge = 3600)</code></p></li><li><p><code>maxAge</code>属性指定了准备响应前的缓存持续的最大时间。就是探测请求的有效期。</p></li><li><p><code>allowCredentials</code>属性表示用户是否可以发送、处理 cookie。默认为false</p></li><li><p><code>allowedHeaders</code> 属性表示允许的请求头部有哪些。</p></li><li><p><code>methods</code> 属性表示允许请求的方法，默认get,post,head</p></li></ul><blockquote><p>如果你不设置他的<strong>value</strong>属性，或者是<strong>origins</strong>属性，就默认是可以允许所有的URL&#x2F;域访问。</p><p><font color="red">value和origins的效果是一样的，当value和origins同时使用时，配置的值不一样会报错!</font></p></blockquote></li><li><p>使用 <code>WebMvcConfigurer</code> 的 <code>addCorsMappings</code> 方法配置<code>CorsInterceptor</code></p><p>使用注解有一个缺陷，当我们的Controller类过多时，就需要频繁加注解。因此我们可以<strong>使用配置类才进行批量映射</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">      <span class="comment">// 设置允许跨域的路径</span></span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                <span class="comment">// 设置允许跨域请求的域名</span></span><br><span class="line">                .allowedOriginPatterns(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                <span class="comment">// 是否允许cookie</span></span><br><span class="line">                .allowCredentials(<span class="literal">true</span>)</span><br><span class="line">                <span class="comment">// 设置允许的请求方式</span></span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;PUT&quot;</span>)</span><br><span class="line">                <span class="comment">// 设置允许的header属性</span></span><br><span class="line">                .allowedHeaders(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                <span class="comment">// 跨域允许时间</span></span><br><span class="line">                .maxAge(<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>addMapping(&quot;/user/**&quot;)</code>：其中* 表示匹配到下一层；** 表示后面不管有多少层，都能匹配。</p></li><li><p><code>allowedOriginPatterns(&quot;http:localhost:8080&quot;)</code>，只有<code>http:localhost:8080</code>可以访问。<code>*</code>表示任意域名</p></li><li><p><code>.maxAge(3600);</code>：</p><p>如果我们使用比较复杂的请求，比如<code>PUT</code>请求。</p><p>那这个请求它不是只发送一个请求，如果是跨域请求，浏览器会先发送一个询问允许我跨域请求的请求。如果服务端是允许的，就会再响应头中添加对应的响应头。</p><p>如果每次请求都发送一个询问请求那就会很浪费时间。</p><p>而<code>maxAge</code>相当于持久的时间。如果我们这个请求被允许了，那在3600秒之内，浏览器再去发送跨域请求，就不会再发送询问请求。</p></li></ul></li></ul><h1 id="当时使用SpringSecurity时"><a href="#当时使用SpringSecurity时" class="headerlink" title="当时使用SpringSecurity时"></a>当时使用SpringSecurity时</h1><p>当有跨域请求时，还得经过<code>SringSecurity</code>的过滤器，光靠<code>SpringBoot</code>是不行的，如果<code>SpringSecurity</code>是不允许跨域的还是不行。</p><p>因此还需要配置<code>SpringSecurity</code>来进行跨域请求。配置方法如下：<code>http.cors();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        http</span><br><span class="line">                <span class="comment">//关闭csrf</span></span><br><span class="line">                .csrf().disable()</span><br><span class="line">                <span class="comment">//不通过Session获取SecurityContext</span></span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                <span class="comment">// 对于登录接口 允许匿名访问</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/user/login&quot;</span>).anonymous()</span><br><span class="line">                <span class="comment">// 除上面外的所有请求全部需要鉴权认证</span></span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line"></span><br><span class="line">        http.cors();<span class="comment">//允许跨域请求</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">什么是跨域请求？如何解决跨域请求？当使用SpringSecurity是进行跨域请求配置。</summary>
    
    
    
    <category term="Spring" scheme="http://example.com/category/Spring/"/>
    
    
    <category term="跨域请求" scheme="http://example.com/tag/%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot静态资源配置</title>
    <link href="http://example.com/post/4c95c618.html"/>
    <id>http://example.com/post/4c95c618.html</id>
    <published>2022-08-24T12:42:15.000Z</published>
    <updated>2022-08-25T10:22:29.021Z</updated>
    
    <content type="html"><![CDATA[<p><code>SpringBoot</code>默认把静态资源文件放在<code>resource/static/</code>，默认的静态资源路径匹配为<code>/** </code>。</p><p>如果我们在<code>resource/static/</code>下放一张图片，启动<code>SpringBoot</code>后去访问它的话。访问路径为**<code>http://localhost:8080/1.png</code>**</p><p>我们可以放置的文件目录有：</p><ul><li><code>resources/static</code></li><li><code>resources/public</code></li><li><code>resources/resources</code> </li><li><code>resources/META-INF/resources</code></li></ul><h2 id="更改静态资源访问路径"><a href="#更改静态资源访问路径" class="headerlink" title="更改静态资源访问路径"></a>更改静态资源访问路径</h2><p>前面我们提到，默认的静态资源访问路径是<code>/**</code></p><p>我们可以通过配置文件来更改静态资源访问路径</p><p><strong>例如：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">static-path-pattern:</span> <span class="string">/res/**</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>资源放置目录</th><th>更改之前访问路径</th><th>更改之后访问路径</th></tr></thead><tbody><tr><td><code>resource/static/login.html</code></td><td><code>localhost:8080/login.html</code></td><td><code>localhost:8080/res/login.html</code></td></tr><tr><td><code>resource/static/page/index.html</code></td><td><code>localhost:8080/page/index.html</code></td><td><code>localhost:8080/res/page/index.html</code></td></tr></tbody></table><p>相当于多了一个前缀<code>/res/</code></p><h2 id="修改静态资源存放目录"><a href="#修改静态资源存放目录" class="headerlink" title="修改静态资源存放目录"></a>修改静态资源存放目录</h2><p>前面我们提到，静态资源只能存在以下目录。</p><ul><li><code>resources/static</code></li><li><code>resources/public</code></li><li><code>resources/resources</code> </li><li><code>resources/META-INF/resources</code></li></ul><p>当我们在<code>resources/</code>，创建了一个目录<code>data</code>【只要不是<code>static</code>、<code>public</code>、<code>resources</code>、<code>META_INF</code>就行】</p><p>把静态资源放在<code>/resouces/data/</code>目录下，启动<code>SpringBoot</code>是无法访问到的。</p><p>那我们想访问到怎么办？</p><p>修改配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">static-locations:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">classpath:/data/</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">classpath:/page/</span></span><br></pre></td></tr></table></figure><p>我们可以添加<strong>多个存放目录</strong>。</p><p>配置之前，<code>SpringBoot</code>它只知道<code>static</code>、<code>public</code>、<code>resources</code>、<code>META-INF/resources</code>这些目录下存放着静态文件。</p><p>配置之后，<code>SpringBoot</code>就知道了 除了<code>static</code>、<code>public</code>、<code>resources</code>、<code>META-INF/resources</code>这些目录下存放着静态文件。<code>data</code>、<code>page</code>这些目录也存放着静态文件。</p><p>当我们访问 <strong><code>/data/1.png</code><strong>文件时，访问路径是：</strong><code>http://localhost:8080/1.png</code></strong></p><h2 id="静态资源映射"><a href="#静态资源映射" class="headerlink" title="静态资源映射"></a>静态资源映射</h2><p>当我们进行如下配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">static-path-pattern:</span> <span class="string">/res/**</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">static-locations:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">classpath:/data/</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">classpath:/page/</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">访问目录</th><th align="center">访问路径</th></tr></thead><tbody><tr><td align="center"><code>/data/1.png</code></td><td align="center"><code>localhost:8080/res/1.png</code></td></tr><tr><td align="center"><code>/page/2.png</code></td><td align="center"><code>localhost:8080/res/2.png</code></td></tr></tbody></table><p>但，如果我们想<font color="red"><strong>实现如下效果</strong></font>：</p><table><thead><tr><th align="center">访问目录</th><th align="center">访问路径</th></tr></thead><tbody><tr><td align="center"><code>/data/1.png</code></td><td align="center"><code>localhost:8080/data/1.png</code></td></tr><tr><td align="center"><code>/page/2.png</code></td><td align="center"><code>localhost:8080/page/2.png</code></td></tr></tbody></table><p>那我们可以经过<font color="blue"><strong>配置类</strong></font>进行配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/data/**&quot;</span>).addResourceLocations(<span class="string">&quot;classpath:/data/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/page/**&quot;</span>).addResourceLocations(<span class="string">&quot;classpath:/page/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">更改静态资源访问路径,更改静态资源存放目录以及静态资源映射</summary>
    
    
    
    <category term="Spring" scheme="http://example.com/category/Spring/"/>
    
    
    <category term="SpringBoot" scheme="http://example.com/tag/SpringBoot/"/>
    
  </entry>
  
</feed>
