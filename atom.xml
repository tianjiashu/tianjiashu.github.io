<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lucky Dog&#39;s blogs</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-08-16T09:22:55.901Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java-IO流</title>
    <link href="http://example.com/post/e530945c.html"/>
    <id>http://example.com/post/e530945c.html</id>
    <published>2022-08-16T08:12:29.000Z</published>
    <updated>2022-08-16T09:22:55.901Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/%5Cimage%5Carticle%5CJava-IO%E6%B5%81%5CIMG_0413(20220816-161354).PNG" alt="IMG_0413(20220816-161354)"></p><ul><li><p>比较基础的是<font color="blue"><strong>字节流</strong></font> <code>InputStream</code>和<code>OutputStream</code>。</p><p>创建对象要传入<font color="red"><strong>路径字符串或者File对象</strong></font></p></li><li><p>为了方便读取字符，所以才有了<font color="blue"><strong>字符流</strong></font>。<code>InputStreamReader</code>和<code>OutputStreamWriter</code>。</p><p>创建对象要传入<font color="red"><strong>字节流对象</strong></font></p><ul><li><p>转换流的名字比较长，为了简化书写，才有了<code>FileReader</code>和<code>FileWriter</code>。专门处理文本文件。</p><p>创建对象要传入<font color="red"><strong>路径字符串</strong></font></p></li></ul></li><li><p>为了更快的读写字节，所以才有了<font color="blue"><strong>字节缓存流</strong></font>。<code>BufferedInputStream</code>和<code>BufferedOutputStream</code>。它只是在字节流上加了缓存效果，</p><p>创建对象需要传入<font color="red"><strong>字节流对象</strong></font></p></li><li><p>为了更快读取字符，有了<font color="blue"><strong>字符缓存流</strong></font>。<code>BufferedWriter</code>和<code>BufferedReader</code>。它是在字符流上加了缓冲效果。</p><p>创建对象要传入<font color="red"><strong>字符流对象</strong></font></p></li></ul><h1 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h1><h2 id="三种构造方法：-路径：D-java-txt"><a href="#三种构造方法：-路径：D-java-txt" class="headerlink" title="三种构造方法：(路径：D:\java.txt)"></a>三种构造方法：(<strong>路径：D:\java.txt</strong>)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\java.txt&quot;</span>);<span class="comment">//直接给定路径字符串</span></span><br><span class="line">System.out.println(file);<span class="comment">//D:\java.txt</span></span><br><span class="line"></span><br><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\&quot;</span>,<span class="string">&quot;java.txt&quot;</span>);<span class="comment">//父路径字符串+子路径名字符串。</span></span><br><span class="line">System.out.println(file1);</span><br><span class="line"></span><br><span class="line"><span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">file3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(file2,<span class="string">&quot;java.txt&quot;</span>);<span class="comment">//父抽象路径名+子路径字符串</span></span><br><span class="line">System.out.println(file3);</span><br><span class="line"><span class="comment">//这三个构造方法做了同样的事情</span></span><br></pre></td></tr></table></figure><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="createNewFile"><a href="#createNewFile" class="headerlink" title="createNewFile()"></a>createNewFile()</h3><p> 如果文件存在，则创建文件再返回true，否则不创建，返回false;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\JavaText\\test1\\src\\IO流\\File\\itcase\\java2.txt&quot;</span>);<span class="comment">//将路径封装</span></span><br><span class="line">System.out.println(file.createNewFile());</span><br></pre></td></tr></table></figure><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir()"></a>mkdir()</h3><p>创建一个文件夹，类似createNewFile()【注意：即使创建的文件夹名有文件后缀，创建的也是文件夹，比如JAVA.txt文件夹】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\JavaText\\test1\\src\\IO流\\File\\itcase&quot;</span>,<span class="string">&quot;javaSE&quot;</span>);</span><br><span class="line">System.out.println(file1.mkdir());</span><br></pre></td></tr></table></figure><h3 id="mkdirs"><a href="#mkdirs" class="headerlink" title="mkdirs()"></a>mkdirs()</h3><p>创建多级目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\JavaText\\test1\\src\\IO流\\File\\itcase&quot;</span>);<span class="comment">//父目录</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(file2,<span class="string">&quot;JAVAEE\\javaee\\javaweb&quot;</span>);<span class="comment">//子目录</span></span><br><span class="line">System.out.println(file3.mkdirs());</span><br></pre></td></tr></table></figure><p><img src="/%5Cimage%5Carticle%5CJava-IO%E6%B5%81%5Cimage-20220816162640221.png" alt="image-20220816162640221"></p><h2 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\JavaText\\test1\\src\\JinJie\\day03\\File\\itcast&quot;</span>);</span><br><span class="line">System.out.println(f.isDirectory());<span class="comment">//isDirectory() 返回此抽象路径名表示的file是否为目录。</span></span><br><span class="line">System.out.println(f.isFile());<span class="comment">//是否是文件</span></span><br><span class="line">System.out.println(f.isAbsolute());<span class="comment">//是否是绝对路径</span></span><br><span class="line">System.out.println(f.exists());<span class="comment">//是否存在</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;\\IO流\\File\\itcase&quot;</span>);</span><br><span class="line">System.out.println(file.getAbsolutePath());<span class="comment">//返回绝对路径</span></span><br><span class="line">System.out.println(file.getPath());<span class="comment">//获取路径  抽象路径---&gt;路径字符串  </span></span><br><span class="line">System.out.println(file.getName());<span class="comment">//返回此路径名表示的文件夹名或文件名  </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">D:\IO流\File\itcase</span></span><br><span class="line"><span class="comment">\IO流\File\itcase</span></span><br><span class="line"><span class="comment">itcase</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a>目录遍历</h2><img src="\image\article\Java-IO流\image-20220816162651470.png" alt="image-20220816162651470" style="zoom:80%;" /><h3 id="list"><a href="#list" class="headerlink" title="list()"></a>list()</h3><p>返回该目录下的文件名称字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\JavaText\\test1\\src\\IO流\\File\\itcase&quot;</span>);</span><br><span class="line">String[] list = file1.list();<span class="comment">//返回该目录下的文件名称字符串</span></span><br><span class="line"><span class="keyword">for</span> (String s:list)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.mp4</span></span><br><span class="line"><span class="comment">java.txt</span></span><br><span class="line"><span class="comment">java2.txt</span></span><br><span class="line"><span class="comment">JAVAEE</span></span><br><span class="line"><span class="comment">javaSE</span></span><br><span class="line"><span class="comment">javase.txt</span></span><br><span class="line"><span class="comment">QQ截图20220102223216.png</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="listFiles"><a href="#listFiles" class="headerlink" title="listFiles()"></a>listFiles()</h3><p>返回该目录下的文件对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\JavaText\\test1\\src\\IO流\\File\\itcase&quot;</span>);</span><br><span class="line">File[] listFiles = file1.listFiles();<span class="comment">//返回该目录下的文件对象</span></span><br><span class="line"><span class="keyword">for</span> (File file2: listFiles)&#123;</span><br><span class="line">    System.out.print(file2.getPath()+<span class="string">&quot;\\\\&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file2.isFile())System.out.println(file2.getName()+<span class="string">&quot;是文件&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">D:\JavaText\test1\src\IO流\File\itcase\1.mp4\\1.mp4是文件</span></span><br><span class="line"><span class="comment">D:\JavaText\test1\src\IO流\File\itcase\java.txt\\java.txt是文件</span></span><br><span class="line"><span class="comment">D:\JavaText\test1\src\IO流\File\itcase\java2.txt\\java2.txt是文件</span></span><br><span class="line"><span class="comment">D:\JavaText\test1\src\IO流\File\itcase\JAVAEE\\</span></span><br><span class="line"><span class="comment">D:\JavaText\test1\src\IO流\File\itcase\javaSE\\</span></span><br><span class="line"><span class="comment">D:\JavaText\test1\src\IO流\File\itcase\javase.txt\\</span></span><br><span class="line"><span class="comment">D:\JavaText\test1\src\IO流\File\itcase\QQ截图20220102223216.png\\QQ截图20220102223216.png是文件</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="删除方法"><a href="#删除方法" class="headerlink" title="删除方法"></a>删除方法</h2><h3 id="delete"><a href="#delete" class="headerlink" title="delete()"></a>delete()</h3><p>如果删除文件夹，若此文件夹不是空文件夹，将删除失败。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\JavaText\\test1\\src\\JinJie\\day03\\File\\itcast&quot;</span>);</span><br><span class="line"><span class="comment">//删除文件夹</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(file,<span class="string">&quot;javase.txt&quot;</span>);</span><br><span class="line">System.out.println(file1.delete());</span><br><span class="line"><span class="comment">//删除文件</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(file,<span class="string">&quot;java.txt&quot;</span>);</span><br><span class="line">System.out.println(file2.delete());</span><br></pre></td></tr></table></figure><h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><p>我们把这种数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为 输入input 和 输出 output ，即流向内存是输入流，流出内存的输出流。 </p><p>根据数据的流向分为：<strong>输入流</strong>和<strong>输出流</strong>。 </p><ul><li><strong>输入流</strong> ：把数据从 其他设备 上读取到 内存 中的流。 </li><li><strong>输出流</strong> ：把数据从 内存 中写出到 其他设备 上的流。</li></ul><p>格局数据的类型分为：<strong>字节流</strong>和<strong>字符流</strong>。 </p><ul><li><strong>字节流</strong> ：以字节为单位，读写数据的流。 </li><li><strong>字符流</strong> ：以字符为单位，读写数据的流</li></ul><h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><h3 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h3><p><code>FileOutputStream</code>类是文件输出流，用于将数据写出到文件。<code>FileOutputStream</code>继承了<code>OutputStream</code></p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>参数：</p><ul><li><code>FileOutputStream(File file)</code> ：创建文件输出流以写入由指定的 File对象表示的文件。  </li><li><code>FileOutputStream(File file, boolean append)</code> ：创建文件输出流以写入由指定的 File对象表示的文件。  </li><li><code>FileOutputStream(String name)</code> ：创建文件输出流以指定的名称写入文件。  </li><li><code>FileOutputStream(String name, boolean append)</code> ：创建文件输出流以指定的名称写入文件。</li></ul><blockquote><p>在该路径下</p><ul><li>如果没有这个文件，会<strong>创建该文件</strong>。</li><li>如果有这个文 件，会<strong>清空这个文件的数据</strong>。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//public FileOutputStream(String name)</span></span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:\\JavaText\\test1\\src\\IO流\\字节流\\java.txt&quot;</span>);</span><br><span class="line"><span class="comment">//public FileOutputStream(File file)</span></span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\JavaText\\test1\\src\\JinJie\\day03\\字节流\\java.txt&quot;</span>));</span><br></pre></td></tr></table></figure><p><font color="red"><strong>数据追加续写</strong></font></p><p><strong><code>public FileOutputStream(File file/String name, boolean append)</code></strong></p><p>参数中需要传入一个boolean类型的值， <strong>true</strong> 表示追加数据， <strong>false</strong> 表示清空原有数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:\\JavaText\\test1\\src\\JinJie\\day03\\字节\\java.txt&quot;</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><p>三种写入数据的方法</p><ul><li><code>void write(byte[] b)</code> ：将 b.length个字节从指定的字节数组写入此文件输出流。  </li><li><code>void write(byte[] b, int off, int len)</code> ：将 len字节从位于偏移量 off的指定字节数组写入此文件输出流。  </li><li><code>void write(int b)</code> ：将指定的字节写入此文件输出流。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建文件输出流以指定名称写入文件</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:\\JavaText\\test1\\src\\IO流\\字节流\\java.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写字节流的三种方式</span></span><br><span class="line">        <span class="comment">//方式一  </span></span><br><span class="line">        fos.write(<span class="number">90</span>);<span class="comment">//ASCII值</span></span><br><span class="line">        <span class="comment">//方式二</span></span><br><span class="line">        fos.write(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">33</span>,<span class="number">23</span>,<span class="number">67</span>,<span class="number">89</span>&#125;);<span class="comment">//一次写一个数组的数据</span></span><br><span class="line">    <span class="comment">//方式三</span></span><br><span class="line">        fos.write(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">30</span>,<span class="number">50</span>,<span class="number">60</span>,<span class="number">61</span>,<span class="number">62</span>,<span class="number">63</span>&#125;,<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//从off开始，写长度为len的数据</span></span><br><span class="line">        fos.close();<span class="comment">//关闭此文件输出流并释放资源。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写入字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;我叫张三！！！&quot;</span>;</span><br><span class="line">fos.write(str.getBytes());<span class="comment">//getBytes()返回字符串对应的字节数组。</span></span><br></pre></td></tr></table></figure><p>写入换行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">不同系统识别换行不一样:</span></span><br><span class="line"><span class="comment">Windows:\r\n</span></span><br><span class="line"><span class="comment">linux:\n</span></span><br><span class="line"><span class="comment">mac:\r</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">fos.write(<span class="string">&quot;hello,world!\r\n&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure><h3 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h3><p><code>FileInputStream </code>类是文件输入流，从文件中读取字节。<code>FileInputStream</code>继承了<code>InputStream</code>。</p><h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><code>FileInputStream(File file)</code> ：通过打开与实际文件的连接创建一个 <code>FileInputStream</code> ，该文件由文件系统中的 File对象 file命名。   </li><li><code>FileInputStream(String name) </code>：通过打开与实际文件的连接来创建一个 <code>FileInputStream</code> ，该文件由文件系统中的路径名 name命名。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\JavaText\\test1\\src\\IO流\\字节流&quot;</span>);</span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\JavaText\\test1\\src\\IO流\\字节流&quot;</span>));</span><br></pre></td></tr></table></figure><h4 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li><code>int read()</code> ：从该输入流读取一个字节的数据。  </li><li><code>int read(byte[] b) </code>：从该输入流读取最多 b.length个字节的数据为字节数组。 </li><li><code>int read(byte[] b, int off, int len) </code>：从该输入流读取最多 len字节的数据为字节数组。</li></ul><p> read 方法，每次可以读取一个字节的数据，提升为int类型，<strong>读取到文件末尾，返回 -1</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> by;</span><br><span class="line"><span class="keyword">while</span> ((by=fis.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.println((<span class="type">char</span>) by);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>read(byte[] b) ，每次读取b的长度个字节到数组中，<strong>返回读取到的有效字节个数</strong>，<strong>读取到末尾时，返回 -1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\JavaText\\test1\\src\\IO流\\字节流\\java.txt&quot;</span>);</span><br><span class="line"><span class="type">byte</span>[] by = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">while</span> ((len=fis.read(by))!=-<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(by,<span class="number">0</span>,len));</span><br><span class="line">&#125;</span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure><p><font color="blue" size=4> <strong>案例：复制图片</strong></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">copyimage</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;C:\\Users\\dell\\Desktop\\QQ截图20220102202037.png&quot;</span>);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:\\JavaText\\test1\\src\\IO流\\字节流\\image.png&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] by = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> read;</span><br><span class="line">        <span class="keyword">while</span> ((read = fis.read(by))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(by,<span class="number">0</span>,read);</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，<strong>可能不会显示完整的字符</strong>，那是因为<strong>一个中文字符可能占用多个字节存储</strong>。所以Java提供一些字符流类，以字符为单位读写数据，<font color="red"><strong>专门用于处理文本文件</strong></font>。</p><p><strong>汉字在存储的时候，无论选择哪种编码存储，第一个字节都是负数</strong><br>如果一个汉字存储:</p><ul><li>如果是<strong>GBK</strong>编码，占用<strong>2个字节</strong></li><li>如果是<strong>UTF-8</strong>,占用<strong>三个字节</strong></li></ul><p>字节流操作中文字符不方便<br><strong>字符流 &#x3D; 字节流+编码表</strong></p><h3 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a>OutputStreamWriter</h3><p><code>OutputStreamWriter</code> 是字符流通向字节流的桥梁：可使用指定的 <strong>charset</strong> 将要写入流中的字符编码成字节。它使用的<strong>字符集可以由名称指定或显式给定</strong>，否则<strong>将接受平台默认的字符集</strong>。</p><h4 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h4><ul><li><code>OutputStreamWriter(OutputStream out)</code>： 创建使用默认字符编码的 <code>OutputStreamWriter</code>。</li><li><code>OutputStreamWriter(OutputStream out, Charset cs) </code>： 创建使用<strong>给定字符集</strong>的 <code>OutputStreamWriter</code>。 </li><li><code>OutputStreamWriter(OutputStream out, CharsetEncoder enc) </code>：创建使用给定<strong>字符集编码器</strong>的 <code>OutputStreamWriter</code>。 </li><li><code>OutputStreamWriter(OutputStream out, String charsetName) </code>：创建使用<strong>指定字符集</strong>的 <code>OutputStreamWriter</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:\\JavaText\\test1\\src\\JinJie\\day03\\字符流\\java.txt&quot;</span></span><br><span class="line">        ),<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:\\JavaText\\test1\\src\\IO流\\字符流\\java.txt&quot;</span></span><br><span class="line">                ), StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure><h4 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h4><p>每次调用 write()  方法都会导致在给定字符（或字符集）上调用编码转换器。在写入底层输出流之前，<strong>得到的这些字节将在缓冲区中累积</strong>。可以指定此缓冲区的大小，不过，默认的缓冲区对多数用途来说已足够大。注意，<strong>传递给  write() 方法的字符没有缓冲</strong>。 </p><ul><li><code>write(char[] cbuf,  int off, int len)</code>：写入字符数组的某一部分。</li><li><code>write(int c)</code>：写入单个字符。</li><li><code>write(String str,int off, int len)</code>：写入字符串的某一部分。</li><li><code>getEncoding()</code>：返回此流使用的字符编码的名称。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">osw.write(<span class="string">&quot;啦啦啦啦！&quot;</span>);</span><br><span class="line">osw.write(<span class="string">&quot;我叫田佳澍&quot;</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">osw.write(<span class="number">101</span>);</span><br><span class="line">osw.write(<span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="number">101</span>,<span class="number">102</span>,<span class="number">103</span>,<span class="number">104</span>&#125;);</span><br><span class="line">osw.close();</span><br></pre></td></tr></table></figure><h3 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h3><p><code>InputStreamReader</code> 是字节流通向字符流的桥梁：它使用指定的 <code>charset</code> 读取字节并将其解码为字符。它使用的字符集可以由名称指定或显式给定，或者可以接受平台默认的字符集。</p><h4 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h4><p>和<code>InputStreamWrite</code>r类似</p><ul><li><code>InputStreamReader(InputStream in)</code>：创建一个使用默认字符集的<code> InputStreamReader</code>。</li><li><code>InputStreamReader(InputStream in, Charset cs) </code>：创建使用给定字符集的 <code>InputStreamReader</code>。 </li><li><code>InputStreamReader(InputStream in, CharsetDecoder dec) </code>：创建使用给定字符集解码器的 <code>InputStreamReader</code>。 </li><li><code>InputStreamReader(InputStream in, String charsetName)</code>：创建使用指定字符集的 <code>InputStreamReader</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\JavaText\\test1\\src\\JinJie\\day03\\字符流\\java.txt&quot;</span>),<span class="string">&quot;GBK&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="常用方法-4"><a href="#常用方法-4" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li><code>getEncoding()</code> 返回此流使用的字符编码的名称。 </li><li><code>int read()</code> 读取单个字符。 </li><li><code>int read(char[] cbuf, int offset, int length)</code> 将字符读入数组中的某一部分。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span> ((i=isr.read(chars))!=-<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(chars,<span class="number">0</span>,i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FileReader-amp-FileWriter"><a href="#FileReader-amp-FileWriter" class="headerlink" title="FileReader&amp;FileWriter"></a>FileReader&amp;FileWriter</h3><p><strong>便捷字符输入输出流</strong>，转换流的名字比较长，而我们常见的操作都是按照本地默认编码实现的，所以，为了简化书写，转换流提供了对应的子类</p><ul><li><code>FileReader</code>:用于读取字符文件的便捷类  <strong>继承<code>InputStreamReader</code> 方法一样</strong><br>      <strong><code>FileReader(String fileName)</code></strong>    </li><li><code>FileWrite</code>r:用于写入字符文件的便捷类    <strong>继承<code>OutputStreamWriter</code> 方法一样</strong><br><strong><code>FileWriter(String fileName)</code></strong></li></ul><p><strong>构造时使用系统默认的字符编码和默认字节缓冲区。</strong></p><p><font color="blue" size=4><strong>案例：复制字符文件</strong></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;D:\\JavaText\\test1\\src\\JinJie\\day01\\Arraysclass.java&quot;</span>);</span><br><span class="line">    <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;D:\\JavaText\\test1\\src\\JinJie\\day03\\字符流\\copy.java&quot;</span>);</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">char</span>[] ch = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> ((len=fr.read(ch))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        fw.write(ch,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    fw.close();</span><br><span class="line">    fr.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关闭和刷新"><a href="#关闭和刷新" class="headerlink" title="关闭和刷新"></a>关闭和刷新</h4><p>因为内置缓冲区的原因，<strong>如果不关闭输出流，无法写出字符到文件中</strong>。但是<strong>关闭的流对象，是无法继续写出数据的</strong>。如果我们既想写出数据，又想继续使用流，就需要 flush 方法了。 </p><ul><li>flush ：刷新缓冲区，流对象可以继续使用。 </li><li>close :先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;D:\\JavaText\\test1\\src\\IO流\\字符流\\java.txt&quot;</span>);</span><br><span class="line">fw.write(<span class="string">&quot;刷新&quot;</span>);</span><br><span class="line">fw.flush();</span><br><span class="line">fw.write(<span class="string">&quot;关闭&quot;</span>);</span><br><span class="line">fw.close();</span><br></pre></td></tr></table></figure><h2 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h2><p>字节缓冲流  **缓冲区大小是默认的，默认值<font color="red">8192</font>**。目的就是加快读取和写入数据的速度</p><p>缓冲流本身并没有IO功能，<strong>只是在别的流上加上缓冲效果从而提高了效率</strong>。当对文件或其他目标频繁读写或操作效率低，效能差时。这时使用缓冲流能够更高效的读写信息。因为缓冲流先将数据缓存起来，然后一起写入或读取出来。所以说，缓冲流还是很重要的，在IO操作时加上缓冲流提升性能。</p><h3 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h3><p><strong>字节缓冲输入流</strong></p><ul><li><code>BufferedInputStream(InputStream in) </code>：创建一个 <code>BufferedInputStream</code> 并保存其参数，即输入流 in，以便将来使用。 </li><li><code>BufferedInputStream(InputStream in, int size) </code>： 创建具有指定缓冲区大小的 <code>BufferedInputStream</code> 并保存其参数，即输入流 in，以便将来使用。</li></ul><p><strong>字节缓冲输出流</strong></p><ul><li><code>BufferedOutputStream(OutputStream out) </code>：创建一个新的缓冲输出流，以将数据写入指定的底层输出流。 </li><li><code>BufferedOutputStream(OutputStream out, int size) </code>：创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:\\JavaText\\test1\\src\\JinJie\\day03\\字节流\\java.txt&quot;</span>)</span><br><span class="line">);</span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\JavaText\\test1\\src\\JinJie\\day03\\字节流\\java.txt&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p>使用数组缓冲流速度&gt;不使用数组的缓冲流&gt;普通字节流</p><p><strong>缓冲流读写方法与基本的流是一致的</strong></p></blockquote><h2 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h2><h3 id="构造方法-5"><a href="#构造方法-5" class="headerlink" title="构造方法"></a>构造方法</h3><p><strong>字符缓冲输入流</strong></p><ul><li><code>BufferedReader(Reader in) </code>：创建一个使用默认大小输入缓冲区的缓冲字符输入流。 </li><li><code>BufferedReader(Reader in, int sz) </code>： 创建一个使用指定大小输入缓冲区的缓冲字符输入流。</li></ul><p> <strong>字符缓冲输出流</strong></p><ul><li><code>BufferedWriter(Writer out) </code>：创建一个使用默认大小输出缓冲区的缓冲字符输出流。 </li><li><code>BufferedWriter(Writer out, int sz) </code>：创建一个使用给定大小输出缓冲区的新缓冲字符输出流。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;D:\\JavaText\\test1\\src\\JinJie\\day03\\字符流\\java.txt&quot;</span>)</span><br><span class="line">);</span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;D:\\JavaText\\test1\\src\\JinJie\\day03\\字符流\\java.txt&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="特有方法"><a href="#特有方法" class="headerlink" title="特有方法"></a>特有方法</h3><p>字符缓冲流的<strong>基本方法</strong>与<strong>普通字符流调用方式一致</strong></p><ul><li><code>BufferedReader</code>： public String <strong>readLine()</strong> : 读一行文字。 </li><li><code>BufferedWrite</code>r： public void <strong>newLine()</strong> : 写一行行分隔符,由系统属性定义符号</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;D:\\JavaText\\test1\\src\\JinJie\\day03\\字符流\\Demo1.java&quot;</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;D:\\JavaText\\test1\\src\\JinJie\\day03\\copy.java&quot;</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    String s;</span><br><span class="line">    <span class="keyword">while</span> ((s=br.readLine())!=<span class="literal">null</span>)&#123;<span class="comment">//一次读取一行，不包括任何终止符。如果流已经到末尾，则返回null</span></span><br><span class="line">        bw.write(s);</span><br><span class="line">        bw.newLine();<span class="comment">//添加换行符，根据不同系统，换行符不同。</span></span><br><span class="line">    &#125;</span><br><span class="line">    bw.close();</span><br><span class="line">    br.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">File类、字节流、字符流、字节缓存流、字符缓存流、便捷字符输入输出流</summary>
    
    
    
    <category term="java基础" scheme="http://example.com/category/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="IO流" scheme="http://example.com/tag/IO%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>Java-Socket编程——TCP</title>
    <link href="http://example.com/post/aa5a87da.html"/>
    <id>http://example.com/post/aa5a87da.html</id>
    <published>2022-08-15T12:16:45.000Z</published>
    <updated>2022-08-16T12:58:30.954Z</updated>
    
    <content type="html"><![CDATA[<p>所谓<code>socket</code> 通常也称作<strong>”套接字“</strong>，用于描述<code>IP</code>地址和端口，是一个通信链的句柄。应用程序通常通过”套接字”向网络发出请求或者应答网络请求。</p><p><font size= 5><strong><code>InetAddress</code></strong></font></p><p><code>InetAddress</code>可以获取对应<code>ip</code>或者对应域名的相关信息，例如<code>ip</code>信息和域名信息</p><p>只说一下用的比较多的吧</p><p>获取<code>InetAddress</code>对象，只能使用工厂构造方法获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取本地主机的相关信息。</span></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">localHost</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">localhost</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line"><span class="comment">//获取主机名为 DESKTOP-GQI06FR 的相关信息</span></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">inetAddress</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;DESKTOP-GQI06FR&quot;</span>);</span><br><span class="line"><span class="comment">//获取网站相关信息</span></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">inetAddress</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>InetAddress</code>对象的使用，常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ip</span></span><br><span class="line"><span class="type">String</span> <span class="variable">hostAddress</span> <span class="operator">=</span> localHost.getHostAddress();<span class="comment">//获取IP地址</span></span><br><span class="line"><span class="comment">//主机名称</span></span><br><span class="line"><span class="type">String</span> <span class="variable">hostName</span> <span class="operator">=</span> localHost.getHostName();<span class="comment">//获取主机名称 或者 域名</span></span><br></pre></td></tr></table></figure><h1 id="TCP客户端"><a href="#TCP客户端" class="headerlink" title="TCP客户端"></a>TCP客户端</h1><p>以发送简单的字符串为例。</p><p>TCP发送数据的步骤</p><ol><li>创建客户端的Socket对象(Socket)</li><li>获取输出流，写数据</li><li>释放资源</li></ol><p><font size= 4><strong>首先创建Socket对象</strong></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">50000</span>);</span><br></pre></td></tr></table></figure><p>常用的构造方法有两个：</p><ul><li><code>Socket (InetAddress address, int port)</code>创建流套接字并将其连接到指定<code>IP</code>地址的指定端口号</li><li><code>Socket (String host, int port)</code>创建流套接字并将其连接到指定主机上的指定端口号</li></ul><p><font size= 4><strong>获取字节输出流</strong></font></p><p>你可以使用普通的<strong>输出流</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br></pre></td></tr></table></figure><p>你还可以使用<strong>字符缓存流</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(socket.getOutputStream()));</span><br></pre></td></tr></table></figure><p>还可以使用<strong>字节缓存流</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(socket.getOutputStream());</span><br></pre></td></tr></table></figure><p><font size= 4><strong>获取字节输入流</strong></font></p><p>获取输入流可以获取<strong>反馈信息</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">clientInputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br></pre></td></tr></table></figure><blockquote><p>字符缓存流和字节缓冲流和上面的类似。</p></blockquote><p><font size= 4><strong>写数据</strong></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">next</span> <span class="operator">=</span> sc.next();</span><br><span class="line"><span class="comment">//使用 普通的输出流</span></span><br><span class="line">stream.write(next.getBytes());</span><br></pre></td></tr></table></figure><p><font size=4><strong>释放资源</strong></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stream.close();</span><br><span class="line">socket.close();</span><br></pre></td></tr></table></figure><h1 id="TCP服务端"><a href="#TCP服务端" class="headerlink" title="TCP服务端"></a>TCP服务端</h1><p><font size=4><strong>创建服务器端的<code>socket</code>对象(<code>ServerSocket</code>)</strong></font></p><p><code>ServerSocket (int port)</code>创建<strong>绑定到指定端口</strong>的服务器套接字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9000</span>);</span><br></pre></td></tr></table></figure><p><font size=4><strong>Socket accept()侦听要连接到此套接字并接受它</strong></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> server.accept();</span><br></pre></td></tr></table></figure><blockquote><p>accept()  阻塞式监听，会一直等待客户端连接</p></blockquote><p><font size=4><strong>获取字节输入流和字节输出流</strong></font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputStream stream = accept.getInputStream();</span><br><span class="line">OutputStream outputStream = accept.getOutputStream();</span><br></pre></td></tr></table></figure><p><font size=4><strong>接收数据</strong></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">while</span> ((len = stream.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span>, len);</span><br><span class="line">    System.out.println(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写的缺点是，假如有中文，超过了1024，然后就断掉了。断掉之后就<strong>乱码</strong>了。</p><p><font color="blue"><strong>管道流</strong></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"><span class="keyword">while</span> ((len = stream.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">    baos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(baos.toString());</span><br></pre></td></tr></table></figure><p><font size=4><strong>关闭资源</strong></font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">accept.close();</span><br><span class="line">stream.close();</span><br><span class="line">outputStream.close();</span><br><span class="line">server.close();</span><br></pre></td></tr></table></figure><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>客户端发送消息字符串，服务端接收消息字符串。客户端输入“exit”结束发送，服务端发送“接收完毕”反馈，客户端接收反馈。</p><p><strong>客户端</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">10001</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream));</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        String text;</span><br><span class="line">        <span class="keyword">while</span> (!(text=sc.next()).equals(<span class="string">&quot;exit&quot;</span>))&#123;</span><br><span class="line">            bw.write(text);</span><br><span class="line">            bw.newLine();</span><br><span class="line">            bw.flush();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        socket.shutdownOutput();<span class="comment">//不使用的话，服务端就会发送阻塞，不会发送反馈，客户端也就会发送阻塞。</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">        System.out.println(line);</span><br><span class="line"></span><br><span class="line">        socket.close();</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>服务端</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">10001</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line"></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> accept.getInputStream();</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream));</span><br><span class="line">        String text;</span><br><span class="line">        <span class="keyword">while</span> ((text = reader.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(text);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> accept.getOutputStream();</span><br><span class="line">        outputStream.write(<span class="string">&quot;接收完毕！&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">        accept.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>关于<code>shutdownOutput()</code>的作用：</p><p><code>socket.shutdownOutput()</code>：关闭客户端的输出流。相当于给流中加入一个结束标志-1，这个时候服务器端的输入流的<code>readLine()</code>相当于读到了一个-1【null】，所以，就会结束<code>while ((text = reader.readLine())!=null)</code>循环，接着往下执行。</p></blockquote><p><img src="/%5Cimage%5Carticle%5CJava-Socket%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94TCP%5Cimage-20220816205526066.png" alt="image-20220816205526066"></p><blockquote><p><strong>IO流相关操作，参考我另一篇博客——Java-IO流</strong></p></blockquote>]]></content>
    
    
    <summary type="html">使用Java-Socket的基本操作。</summary>
    
    
    
    <category term="java基础" scheme="http://example.com/category/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Socket编程" scheme="http://example.com/tag/Socket%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Python-Socket编程 —— TCP</title>
    <link href="http://example.com/post/7d13d7e5.html"/>
    <id>http://example.com/post/7d13d7e5.html</id>
    <published>2022-08-15T06:27:49.000Z</published>
    <updated>2022-08-15T12:18:31.444Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><strong>Socket是应用层与TCP&#x2F;IP协议族通信的中间软件抽象层</strong>。</p><p>复杂的TCP&#x2F;IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，<strong>让Socket去组织数据，以符合指定的协议。</strong></p><p><img src="/%5Cimage%5Carticle%5CPython-Socket%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%5Cimage-20220815163449720.png" alt="image-20220815163449720"></p><p>要进行socket编程，发送网络消息，我们可以使用 Python 内置的 socket 库 。</p><p>目前的socket编程，使用的最多的就是通过TCP协议进行网络通讯的。</p><p>TCP进行通讯的程序双方，分为服务端和客户端。</p><p>TCP 协议进行通讯的双方，是需要先建立一个虚拟连接的。然后双方程序才能发送业务数据信息。</p><p>建立TCP虚拟连接是通过著名的 <strong>三次握手</strong> 进行的。</p><h1 id="TCP服务端程序"><a href="#TCP服务端程序" class="headerlink" title="TCP服务端程序"></a><strong>TCP服务端程序</strong></h1><h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><h3 id="首先需要导入socket-库"><a href="#首先需要导入socket-库" class="headerlink" title="首先需要导入socket 库"></a>首先需要导入socket 库</h3><p>Python里面对Socket接口的调用全部封装到了socket库里了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><h3 id="定义配置项"><a href="#定义配置项" class="headerlink" title="定义配置项"></a>定义配置项</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 等待客户端来连接</span></span><br><span class="line">IP = <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line"><span class="comment"># 端口号</span></span><br><span class="line">PORT = <span class="number">50000</span></span><br><span class="line"><span class="comment"># 定义一次从socket缓冲区最多读入512个字节数据</span></span><br><span class="line">BUFLEN = <span class="number">512</span></span><br></pre></td></tr></table></figure><p>这个IP是指<font color='red'><strong>“哪个IP可以连接你这个服务端“</strong></font></p><p>如果<code>IP = &#39;0.0.0.0&#39;</code>就表示所有IP地址都可以连接这个服务端。</p><h3 id="实例化一个Socket对象"><a href="#实例化一个Socket对象" class="headerlink" title="实例化一个Socket对象"></a>实例化一个<code>Socket</code>对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">listenSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"><span class="comment"># socket绑定地址和端口 </span></span><br><span class="line">listenSocket.bind((IP, PORT))</span><br><span class="line"><span class="comment"># 参数 8 表示 最多接受多少个等待连接的客户端</span></span><br><span class="line">listenSocket.listen(<span class="number">8</span>)</span><br></pre></td></tr></table></figure><ul><li>参数 <code>AF_INET</code> 表示<strong>该socket网络层使用<font color="red">IP</font>协议</strong></li><li>参数 <code>SOCK_STREAM</code> 表示<strong>该socket传输层使用<font color="red">TCP</font>协议</strong></li></ul><p><code>listenSocket.bind((IP, PORT))</code>绑定IP和PORT后，表示将监听该端口号和IP地址。</p><p><code>listenSocket.listen(8)</code>，然后就进入<strong>等待连接</strong>的状态，最多接受8个客户端。</p><h3 id="获取请求"><a href="#获取请求" class="headerlink" title="获取请求"></a>获取请求</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataSocket, addr = listenSocket.accept()</span><br></pre></td></tr></table></figure><p>返回的是一个元组，用两个变量接收</p><ul><li>dataSocket：是一个<strong>新的Socket对象</strong>。</li><li>addr：是客户端地址，包括（IP地址，端口号），例如：<code>(&#39;127.0.0.1&#39;, 61799)</code>。</li></ul><blockquote><p>注意：当调用了  accept()  方法，服务端程序就处于了<strong>阻塞状态</strong>，一直等待连接，如果没有连接，下面的代码就不会执行。直到接收到了连接。</p></blockquote><h3 id="接收数据并处理"><a href="#接收数据并处理" class="headerlink" title="接收数据并处理"></a>接收数据并处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 尝试读取对方发送的消息</span></span><br><span class="line">    <span class="comment"># BUFLEN 指定从接收缓冲里最多读取多少字节</span></span><br><span class="line">    recved = dataSocket.recv(BUFLEN)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果返回空bytes，表示对方关闭了连接</span></span><br><span class="line">    <span class="comment"># 退出循环，结束消息收发</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> recved:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取的字节数据是bytes类型，需要解码为字符串</span></span><br><span class="line">    info = recved.decode()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;收到对方信息： <span class="subst">&#123;info&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 发送的数据类型必须是bytes，所以要编码</span></span><br><span class="line">    dataSocket.send(<span class="string">f&#x27;服务端接收到了信息 <span class="subst">&#123;info&#125;</span>&#x27;</span>.encode())</span><br></pre></td></tr></table></figure><p><code>recv(BUFLEN)</code>方法返回的是 <strong>字节串</strong>类似Java的<strong>字节流</strong>，如果客户端关闭了，那么就会返回<code>b&#39;&#39;</code>。</p><ul><li><p><code>str.decode(encoding=&#39;UTF-8&#39;,errors=&#39;strict&#39;) </code>字符串解码 </p><ul><li><p>默认使用<code>UTF-8</code></p></li><li><p>errors – 设置不同错误的处理方案。默认为 <code>strict</code>,意为编码错误引起一个UnicodeError。</p><p> 其他可能得值有  <code>ignore</code>, <code>replace</code>, <code>xmlcharrefreplace</code>, <code>backslashreplace</code> 以及通过  codecs.register_error() 注册的任何值。</p></li></ul></li><li><p><code>str.encode(encoding=&#39;UTF-8&#39;,errors=&#39;strict&#39;)</code>字符串编码【参数和<code>decode()</code>一样】</p></li></ul><blockquote><p>收发数据不一定是字符串，可以是其他数据，比如 图片音频等…</p><p>recv(BUFLEN) 方法也会使程序处于<strong>阻塞状态</strong>，一直等待的是数据，而accept() 等待的是连接。</p></blockquote><h3 id="最后关闭连接"><a href="#最后关闭连接" class="headerlink" title="最后关闭连接"></a>最后关闭连接</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务端也调用close()关闭socket</span></span><br><span class="line">dataSocket.close()</span><br><span class="line">listenSocket.close()</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  === TCP 服务端程序 server.py ===</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入socket 库</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主机地址为空字符串，表示绑定本机所有网络接口ip地址</span></span><br><span class="line"><span class="comment"># 等待客户端来连接</span></span><br><span class="line">IP = <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line"><span class="comment"># 端口号</span></span><br><span class="line">PORT = <span class="number">50000</span></span><br><span class="line"><span class="comment"># 定义一次从socket缓冲区最多读入512个字节数据</span></span><br><span class="line">BUFLEN = <span class="number">512</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化一个socket对象</span></span><br><span class="line"><span class="comment"># 参数 AF_INET 表示该socket网络层使用IP协议</span></span><br><span class="line"><span class="comment"># 参数 SOCK_STREAM 表示该socket传输层使用TCP协议</span></span><br><span class="line">listenSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># socket绑定地址和端口</span></span><br><span class="line">listenSocket.bind((IP, PORT))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使socket处于监听状态，等待客户端的连接请求</span></span><br><span class="line"><span class="comment"># 参数 8 表示 最多接受多少个等待连接的客户端</span></span><br><span class="line">listenSocket.listen(<span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;服务端启动成功，在<span class="subst">&#123;PORT&#125;</span>端口等待客户端连接...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">dataSocket, addr = listenSocket.accept()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;接受一个客户端连接:&#x27;</span>, addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 尝试读取对方发送的消息</span></span><br><span class="line">    <span class="comment"># BUFLEN 指定从接收缓冲里最多读取多少字节</span></span><br><span class="line">    recved = dataSocket.recv(BUFLEN)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果返回空bytes，表示对方关闭了连接</span></span><br><span class="line">    <span class="comment"># 退出循环，结束消息收发</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> recved:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取的字节数据是bytes类型，需要解码为字符串</span></span><br><span class="line">    info = recved.decode()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;收到对方信息： <span class="subst">&#123;info&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 发送的数据类型必须是bytes，所以要编码</span></span><br><span class="line">    dataSocket.send(<span class="string">f&#x27;服务端接收到了信息 <span class="subst">&#123;info&#125;</span>&#x27;</span>.encode())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务端也调用close()关闭socket</span></span><br><span class="line">dataSocket.close()</span><br><span class="line">listenSocket.close()</span><br></pre></td></tr></table></figure><h1 id="TCP客户端程序"><a href="#TCP客户端程序" class="headerlink" title="TCP客户端程序"></a><strong>TCP客户端程序</strong></h1><p>经过服务端程序讲解，客户端的程序就不做详解。一样，直接上代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  === TCP 客户端程序 client.py ===</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">IP = <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">SERVER_PORT = <span class="number">50000</span></span><br><span class="line">BUFLEN = <span class="number">1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例化一个socket对象，指明协议</span></span><br><span class="line">dataSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接服务端socket</span></span><br><span class="line">dataSocket.connect((IP, SERVER_PORT))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 从终端读入用户输入的字符串</span></span><br><span class="line">    toSend = <span class="built_in">input</span>(<span class="string">&#x27;&gt;&gt;&gt; &#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span>  toSend ==<span class="string">&#x27;exit&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 发送消息，也要编码为 bytes</span></span><br><span class="line">    dataSocket.send(toSend.encode())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待接收服务端的消息</span></span><br><span class="line">    recved = dataSocket.recv(BUFLEN)</span><br><span class="line">    <span class="comment"># 如果返回空bytes，表示对方关闭了连接</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> recved:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 打印读取的信息</span></span><br><span class="line">    <span class="built_in">print</span>(recved.decode())</span><br><span class="line"></span><br><span class="line">dataSocket.close()</span><br></pre></td></tr></table></figure><blockquote><p>其实，客户端的connect() 方法对应着服务端的 accept()方法，进行了三次握手。</p></blockquote>]]></content>
    
    
    <summary type="html">使用Python内置的socket库进行网络编程，接发字符串。</summary>
    
    
    
    <category term="Python" scheme="http://example.com/category/Python/"/>
    
    
    <category term="Socket编程" scheme="http://example.com/tag/Socket%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java泛型机制（三）深入理解泛型</title>
    <link href="http://example.com/post/1eb4aa8d.html"/>
    <id>http://example.com/post/1eb4aa8d.html</id>
    <published>2022-08-11T08:17:29.000Z</published>
    <updated>2022-08-11T08:46:40.601Z</updated>
    
    <content type="html"><![CDATA[<p>泛型不能万能的，有些事情，泛型真做不了。</p><h1 id="泛型类型能不能实例化？"><a href="#泛型类型能不能实例化？" class="headerlink" title="泛型类型能不能实例化？"></a>泛型类型能不能实例化？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T test = new T(); // ERROR</span><br></pre></td></tr></table></figure><p>因为在 Java 编译期<font color="red"><strong>没法确定泛型参数化类型</strong></font>，也就<font color="red"><strong>找不到对应的类字节码文件</strong></font>，所以自然就不行了。</p><p>此外由于<code>T</code> 被擦除为 <code>Object</code>，如果可以 <code>new T()</code> 则就变成了 <code>new Object()</code>，失去了本意。  </p><h1 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h1><p>泛型数组相关的申明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] list11 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;[<span class="number">10</span>]; <span class="comment">//编译错误，非法创建 </span></span><br><span class="line">List&lt;String&gt;[] list12 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;?&gt;[<span class="number">10</span>]; <span class="comment">//编译错误，需要强转类型 </span></span><br><span class="line">List&lt;String&gt;[] list13 = (List&lt;String&gt;[]) <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;?&gt;[<span class="number">10</span>]; <span class="comment">//OK，但是会有警告 </span></span><br><span class="line">List&lt;?&gt;[] list14 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;[<span class="number">10</span>]; <span class="comment">//编译错误，非法创建 </span></span><br><span class="line">List&lt;?&gt;[] list15 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;?&gt;[<span class="number">10</span>]; <span class="comment">//OK </span></span><br><span class="line">List&lt;String&gt;[] list6 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[<span class="number">10</span>]; <span class="comment">//OK，但是会有警告</span></span><br></pre></td></tr></table></figure><p>因为在 Java 中是不能创建一个确切的泛型类型的数组的，除非是采用通配符的方式且要做显式类型转换才可以。</p><p>需要说明的是， 只是不允许创建这些数组， 而声明类型为 <code>ArrayList&lt;String&gt;[]</code> 的变量仍是合法的。<strong>不过不能用 <code>new ArrayList&lt;String&gt;[10]</code> 初始化这个变量。</strong></p><p>因为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt;[] pairs = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;String&gt;[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//擦除之后</span></span><br><span class="line">Pair[] pairs = <span class="keyword">new</span> <span class="title class_">Pair</span>[<span class="number">10</span>];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">数组会记住他的元素类型。这是一个安全措施。对于这样的数组，将他转换为Object[]。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Pair[] pairs = <span class="keyword">new</span> <span class="title class_">Pair</span>[<span class="number">10</span>];</span><br><span class="line">Object[] objects = pairs;</span><br><span class="line">objects[<span class="number">0</span>] = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">编译器不会报错，但数组会记住他的元素类型，运行后会报ArrayStoreException.</span></span><br><span class="line"><span class="comment">pairs会记得他是Pair数组，但他并不记得自己是Pair&lt;String&gt;数组还是Pair&lt;Interger&gt;数组</span></span><br><span class="line"><span class="comment">如果我们在Pair&lt;String&gt;数组中放入Pair&lt;Interget&gt;是不会得到ArrayStoreException异常，但这是不安全的。因此参数化类型的数组是完全禁止的。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>讨巧的使用场景</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsDemo30</span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;  </span><br><span class="line">        Integer i[] = fun1(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>) ;   <span class="comment">// 返回泛型数组  </span></span><br><span class="line">        fun2(i) ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] fun1(T...arg)&#123;  <span class="comment">// 接收可变参数  </span></span><br><span class="line">        <span class="keyword">return</span> arg ;            <span class="comment">// 返回泛型数组  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">fun2</span><span class="params">(T param[])</span>&#123;   <span class="comment">// 输出  </span></span><br><span class="line">        System.out.print(<span class="string">&quot;接收泛型数组：&quot;</span>) ;  </span><br><span class="line">        <span class="keyword">for</span>(T t:param)&#123;  </span><br><span class="line">            System.out.print(t + <span class="string">&quot;、&quot;</span>) ;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="如何实例化一个泛型类和泛型数组"><a href="#如何实例化一个泛型类和泛型数组" class="headerlink" title="如何实例化一个泛型类和泛型数组"></a>如何实例化一个泛型类和泛型数组</h1><p> 如果我们确实需要实例化一个泛型，应该如何做呢？<font color="red" size=5>反射！</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">newTclass</span> <span class="params">(Class &lt; T &gt; clazz)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> newTclass(String.class);<span class="comment">//实例化一个泛型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那我们如何实例化泛型数组呢？<font color="red" size=5>还是反射！</font></p><p>我们可以通过使用 <code>java.lang.reflect.Array.newInstance(Class&lt;T&gt; componentType, int length)</code> 方法来创建一个具有指定类型和维度的数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayWithTypeToken</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T[] array;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayWithTypeToken</span><span class="params">(Class&lt;T&gt; type, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        array = (T[]) Array.newInstance(type, size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> index, T item)</span> &#123;</span><br><span class="line">        array[index] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> array[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T[] create() &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        ArrayWithTypeToken&lt;Integer&gt; arrayToken = <span class="keyword">new</span> <span class="title class_">ArrayWithTypeToken</span>&lt;Integer&gt;(Integer.class, <span class="number">100</span>);</span><br><span class="line">        Integer[] array = arrayToken.create();<span class="comment">//实例化一个泛型数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="如何理解泛型类中的静态方法和静态变量？"><a href="#如何理解泛型类中的静态方法和静态变量？" class="headerlink" title="如何理解泛型类中的静态方法和静态变量？"></a>如何理解泛型类中的静态方法和静态变量？</h1><p>泛型类中的静态方法和静态变量不可以使用泛型类所声明的泛型类型参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span>&lt;T&gt; &#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T one;   <span class="comment">//编译错误    </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  T <span class="title function_">show</span><span class="params">(T one)</span>&#123; <span class="comment">//编译错误    </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为泛型类中的<strong>泛型参数的实例化</strong>是在<strong>定义对象的时候指定</strong>的，而<strong>静态变量和静态方法不需要使用对象来调用。</strong></p><p>对象都没有创建，如何确定这个泛型参数是何种类型，所以当然是错误的。</p><p>但注意区分以下情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span>&lt;T&gt; &#123;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T &gt;T <span class="title function_">show</span><span class="params">(T one)</span>&#123; <span class="comment">//这是正确的    </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这是一个泛型方法，在泛型方法中使用的T是自己在方法中定义的 T，而不是泛型类中的T。</p>]]></content>
    
    
    <summary type="html">泛型数组，泛型类能不能实例化？以及如何理解泛型类中的静态方法和静态变量?</summary>
    
    
    
    <category term="java基础" scheme="http://example.com/category/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="泛型" scheme="http://example.com/tag/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java泛型机制（二）深入理解泛型——类型擦除</title>
    <link href="http://example.com/post/ae19fff4.html"/>
    <id>http://example.com/post/ae19fff4.html</id>
    <published>2022-08-10T14:03:18.000Z</published>
    <updated>2022-08-11T07:41:11.579Z</updated>
    
    <content type="html"><![CDATA[<p><strong>JAVA虚拟机没有泛型类型或方法的概念</strong></p><p>编译器通过<strong>擦除</strong>类型变量将泛型类和方法转换为普通类和普通的方法。</p><p>JAVA泛型出来的比较晚，被设计的主要目标是允许泛型代码和遗留代码之间能够相互操作。也就是说<code>java</code>中的泛型是<font color="red"><strong>“伪泛型”</strong></font></p><h1 id="如何理解Java中的泛型是伪泛型？泛型中类型擦除"><a href="#如何理解Java中的泛型是伪泛型？泛型中类型擦除" class="headerlink" title="如何理解Java中的泛型是伪泛型？泛型中类型擦除"></a><strong>如何理解Java中的泛型是伪泛型？泛型中类型擦除</strong></h1><p>​<code>Java</code>泛型这个特性是从<code>JDK 1.5</code>才开始加入的，因此为了兼容之前的版本，Java泛型的实现采取了“<strong>伪泛型</strong>”的策略，即Java在语法上支持泛型，但是在<font color="red"><strong>编译阶段</strong></font>会进行所谓的“<strong>类型擦除</strong>”（Type Erasure）。</p><p><font color="red"><strong>类型擦除</strong></font>：将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型）【<code>E</code> —&gt;  <code>Object</code>】，就像完全没有泛型一样。理解类型擦除对于用好泛型是很有帮助的，尤其是一些看起来“疑难杂症”的问题，弄明白了类型擦除也就迎刃而解了。</p><p><font color="red"><strong>类型擦除原则</strong></font>：</p><ul><li><p>类型参数声明 —&gt; 被消除   例：<code>public List&lt;E&gt;&#123;...&#125;</code>  —–&gt;  <code>public List&#123;...&#125;</code></p></li><li><p>根据类型参数的上下界推断并替换所有的类型参数为原生态类型</p><ul><li><p>类型参数是<font color="blue"><strong>无限制通配符</strong></font>或<font color="blue"><strong>没有上下界限定</strong></font>则替换为Object</p><p> 例：类型声明为<code>&lt;E&gt;或&lt;?&gt;</code>  <strong>:</strong><code>private E name</code>   ——&gt;   <code>private Object name</code></p></li><li><p><font color="blue"><strong>存在上下界限定</strong></font>则根据子类替换原则取**类型参数的最左边限定类型(即第一个)**（即父类）。</p><p>例: 类型声明为<code>&lt;E extends Number&gt;</code> <strong>:</strong>   <code>private E age</code>   ——&gt;   <code>private Number age</code></p></li></ul></li><li><p>为了保证类型安全，必要时插入强制类型转换代码。</p></li><li><p>自动产生<strong>“桥接方法”</strong>以保证擦除类型后的代码仍然具有泛型的“多态性”</p></li></ul><h2 id="类型擦除示例"><a href="#类型擦除示例" class="headerlink" title="类型擦除示例"></a>类型擦除示例</h2><ul><li><p>擦除类定义中的类型参数</p><ul><li><p>无限制类型擦除</p><p><img src="/%5Cimage%5Carticle%5CJava%E6%B3%9B%E5%9E%8B%E6%9C%BA%E5%88%B6%EF%BC%88%E4%BA%8C%EF%BC%89%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%B3%9B%E5%9E%8B%5Cjava-basic-generic-1.png" alt="java-basic-generic-1"></p></li><li><p>有限制类型擦除</p><p><img src="/%5Cimage%5Carticle%5CJava%E6%B3%9B%E5%9E%8B%E6%9C%BA%E5%88%B6%EF%BC%88%E4%BA%8C%EF%BC%89%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%B3%9B%E5%9E%8B%5Cjava-basic-generic-2.png" alt="java-basic-generic-2"></p></li><li><p>多个有限制类型擦除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span> &amp; Cloneable &gt;&#123;<span class="comment">//替换为第一个限定类型</span></span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">show</span><span class="params">(T a,T b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.compareTo(b)==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//=======================擦除之后的===============================</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Comparable first;<span class="comment">//替换为限定类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">show</span><span class="params">(Comparable a,Comparable b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.compareTo(b)==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>擦除返回类型时，编译器会插入<strong>类型强制转换</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用时</span></span><br><span class="line">Pair&lt;Integer&gt; pair = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;();</span><br><span class="line"><span class="type">Integer</span> <span class="variable">first</span> <span class="operator">=</span> pair.getFirst();</span><br><span class="line"><span class="comment">//擦除之后</span></span><br><span class="line"><span class="type">Pair</span> <span class="variable">pair</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pair</span>();</span><br><span class="line"><span class="type">Integer</span> <span class="variable">first</span> <span class="operator">=</span> (Integer) pair.getFirst();<span class="comment">//插入一个强制类型转换</span></span><br></pre></td></tr></table></figure></li><li><p>参数类型<strong>不需要强制转换</strong>,因为它被擦除为Object。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; pair1 = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;();</span><br><span class="line">pair1.setFirst(<span class="string">&quot;1234&quot;</span>);</span><br><span class="line"><span class="comment">//-------------------------------</span></span><br><span class="line"><span class="type">Pair</span> <span class="variable">pair1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pair</span>();</span><br><span class="line">pair1.setFirst(<span class="string">&quot;1234&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>擦除方法定义中的类型参数</p><p><img src="/%5Cimage%5Carticle%5CJava%E6%B3%9B%E5%9E%8B%E6%9C%BA%E5%88%B6%EF%BC%88%E4%BA%8C%EF%BC%89%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%B3%9B%E5%9E%8B%5Cjava-basic-generic-3.png" alt="java-basic-generic-3"></p></li></ul><h1 id="如何证明类型擦除"><a href="#如何证明类型擦除" class="headerlink" title="如何证明类型擦除"></a>如何证明类型擦除</h1><p><font size= 4><strong>例一  原始类型相等</strong></font></p><p>定义两个<code>ArrayList</code>。</p><p>一个泛型是<code>String</code>，只能添加<code>String </code>类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; stringlist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>一个泛型是<code>Integer</code>，只能添加<code>Integer</code>类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; integerlist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>比较他俩<code>Class</code>对象。我们会发现结果为true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(stringlist.getClass() == integerlist.getClass());<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><strong>同一对象的<code>Class</code>对象是等同的</strong>，因此由此可以得出，即使泛型不一样，但他们的原始类型是相等的。</p><blockquote><p><font size=4><strong>关于Class对象</strong></font></p><p>​这个<code>Class</code>对象是在编译之后生成的，之所以相等，是因为泛型被擦除为了原始类型。</p><p>​每个通过关键字class标识的类，在内存中有且只有一个与之对应的Class对象来描述其类型信息，无论创建多少个实例对象，其依据的都是用一个Class对象。</p></blockquote><p><font size= 4><strong>例二  通过反射添加其它类型元素</strong></font></p><p>定义一个<code>ArrayList&lt;Integer&gt;</code>，通过<code>add()</code>方法只能添加<code>Integer</code>类型的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();         </span><br><span class="line">list.add(<span class="number">1</span>);  </span><br></pre></td></tr></table></figure><p>但我们可以&#x3D;&#x3D;<strong>通过反射绕过泛型检查</strong>&#x3D;&#x3D;，进而添加其他类型的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.getClass().getMethod(<span class="string">&quot;add&quot;</span>, Object.class).invoke(list, <span class="string">&quot;asd&quot;</span>);</span><br></pre></td></tr></table></figure><p>这说明了<code>Integer</code>泛型实例在编译之后被擦除掉了，只保留了原始类型。</p><blockquote><p><font size=4><strong>为什么反射可以绕过泛型检查？</strong></font></p><p>因为，<strong>泛型检查是在<font color="blue">编译期间</font><strong>进行的，而</strong>反射获取的是已经<font color="blue">编译之后</font>的</strong>。之所以能通过反射添加其他类型元素，就是因为编译之后，泛型被擦除掉了，回归成了<font color="purple"><strong>原始类型</strong></font>，可以理解为等价于<code>ArrayList&lt;Object&gt; list = new Arraylist&lt;&gt;();</code>，可以添加任何类型的元素，因为泛型被擦除成了Object</p></blockquote><h1 id="什么是原始类型？如何理解？"><a href="#什么是原始类型？如何理解？" class="headerlink" title="什么是原始类型？如何理解？"></a>什么是原始类型？如何理解？</h1><p><strong>原始类型</strong> 就是&#x3D;&#x3D;擦除去了泛型信息，最后在字节码中的类型变量的真正类型&#x3D;&#x3D;，无论何时定义一个泛型，相应的原始类型都会被自动提供，类型变量擦除，并使用其<strong>限定类型（无限定的变量用Object）替换</strong>。</p><p>其实在泛型类中，不指定泛型的时候，也差不多，只不过这个时候的泛型为Object，就比如<code>ArrayList</code>中，如果不指定泛型，那么这个<code>ArrayList</code>可以存储任意的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">arrayList.add(<span class="number">1</span>);</span><br><span class="line">arrayList.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">arrayList.add(<span class="number">12.2</span>);</span><br></pre></td></tr></table></figure><h1 id="如何理解泛型的编译期检查？"><a href="#如何理解泛型的编译期检查？" class="headerlink" title="如何理解泛型的编译期检查？"></a>如何理解泛型的编译期检查？</h1><p>当我们定义一个<code>ArrangList</code>，并指定泛型为<code>String</code>类型，然后就只能<strong>添加</strong>或者<strong>获取</strong><code>String</code>类型的数据。当添加其他类型的数据时，就会报错，这是为什么呢？这是因为存在编译期检查。</p><p>&#x3D;&#x3D;Java编译器是通过先<strong>检查代码中泛型的类型</strong>，然后在进行<strong>类型擦除</strong>，再进行<strong>编译</strong>。&#x3D;&#x3D;</p><p>类型擦除后，原始类型为<code>Object</code>，但不允许任意引用类型添加，这恰恰说明了关于泛型变量的使用，是会在<strong>编译之前检查</strong>的。</p><h2 id="类型检查针对谁？"><a href="#类型检查针对谁？" class="headerlink" title="类型检查针对谁？"></a>类型检查针对谁？</h2><p><strong>类型检查就是针对<font color="red">引用</font>的，谁是一个引用，用这个引用调用泛型方法，就会对这个引用调用的方法进行类型检测，而无关它真正引用的对象</strong>。</p><p>例一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); <span class="comment">//有警告</span></span><br><span class="line">list1.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">list1.add(<span class="number">123</span>);<span class="comment">//报错!</span></span><br></pre></td></tr></table></figure><p>类型检查针对<code>ArrayList&lt;String&gt;</code>这个引用。当调用这个引用的方法<code>add()</code>，就根据<code>&lt;String&gt;</code>这个类型进行检查。</p><p>例二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(); <span class="comment">//有警告</span></span><br><span class="line">list2.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">list2.add(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>以上没有报错，类型检查针对<code>ArrayList</code>，当调用方法<code>add()</code>时，由于没有指定泛型，所以使用<code>Object</code>进行检查。</p><h2 id="泛型中参数化类型不考虑继承关系"><a href="#泛型中参数化类型不考虑继承关系" class="headerlink" title="泛型中参数化类型不考虑继承关系"></a>泛型中参数化类型不考虑继承关系</h2><p><strong>情况一<code>ArrayList&lt;String&gt; list1 = new ArrayList&lt;Object&gt;();</code>：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Object&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();  </span><br><span class="line">list1.add(<span class="keyword">new</span> <span class="title class_">Object</span>());  </span><br><span class="line">list1.add(<span class="keyword">new</span> <span class="title class_">Object</span>());  </span><br><span class="line">ArrayList&lt;String&gt; list2 = list1; <span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure><p>我们假设以上编译成功····</p><p><code>list.get()</code>获取的是<code>String</code>类型。但我们之前添加的是<code>Object</code>类型，我们知道，Java中对象直接向下转型的【<font color="red"><strong>只有向上转型过的对象才能向下转型</strong></font>】。</p><p>这样就会有<code>ClassCastException</code>了。所以为了避免这种极易出现的错误，Java不允许进行这样的引用传递。(也违背了设计的初衷)</p><p><strong>情况二<code>ArrayList&lt;Object&gt; list2 = new ArrayList&lt;String&gt;();</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();  </span><br><span class="line">list1.add(<span class="keyword">new</span> <span class="title class_">String</span>());  </span><br><span class="line">list1.add(<span class="keyword">new</span> <span class="title class_">String</span>());</span><br><span class="line"></span><br><span class="line">ArrayList&lt;Object&gt; list2 = list1; <span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure><p>这样的情况比第一种情况好的多，最起码，在我们用<code>list2</code>取值的时候不会出现<code>ClassCastException</code>，因为是从<code>String</code>转换为<code>Object</code>。可是，这样做有什么意义呢，泛型出现的原因，就是为了解决类型转换的问题。</p><p>我们使用了泛型，到头来，还是要自己强转，违背了泛型设计的初衷。所以<code>java</code>不允许这么干。再说，你如果又用<code>list2</code>往里面add()新的对象，那么到时候取得时候，我怎么知道我取出来的到底是<code>String</code>类型的，还是<code>Object</code>类型的呢？</p><h1 id="如何理解泛型的多态【桥方法】"><a href="#如何理解泛型的多态【桥方法】" class="headerlink" title="如何理解泛型的多态【桥方法】"></a>如何理解泛型的多态【桥方法】</h1><h2 id="为什么类型擦除会造成多态的冲突？"><a href="#为什么类型擦除会造成多态的冲突？" class="headerlink" title="为什么类型擦除会造成多态的冲突？"></a>为什么类型擦除会造成多态的冲突？</h2><p>现在有这样一个泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T value;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T value)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义一个类继承这个泛型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DateInter</span> <span class="keyword">extends</span> <span class="title class_">Pair</span>&lt;Date&gt; &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  <span class="comment">//重写覆盖</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Date value)</span> &#123;  </span><br><span class="line">        <span class="built_in">super</span>.setValue(value);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  <span class="comment">//重写覆盖</span></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getValue();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，有这样的一个事实，类<code>DateInter</code>继承了一个泛型类<code>Pair&lt;T&gt;</code>。</p><p>类型擦除后，父类的的泛型类型全部变为了原始类型Object，所以父类编译之后会变成下面的样子：</p><img src="\image\article\Java泛型机制（二）深入理解泛型\image-20220811144206244.png" alt="image-20220811144206244" style="zoom:67%;" /><p>让我们回忆一下什么是<strong>重写</strong>，什么是<strong>重载</strong></p><blockquote><p>重写：指子类实现了一个与父类在方法声明上<strong>完全相同</strong>的一个方法。</p><p>重载：存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是<strong>参数</strong>类型、个数、顺序至少有一个不同。</p></blockquote><p><code>setValue</code>方法，在父类类型擦除之后，还算是重写吗？</p><p>父类的参数类型是<code>Object</code>，子类的参数类型是<code>Date</code>。</p><p>这根本不是重写，而是重载。</p><p>我们的本意是：<strong>进行重写，实现多态。</strong></p><p>但是事实是：<strong>类型擦除后，只能变为了重载。</strong></p><p>这样，<font color="red" size=5><strong>类型擦除就和多态有了冲突。</strong></font></p><h2 id="JVM如何解决类型擦除和多态的冲突？"><a href="#JVM如何解决类型擦除和多态的冲突？" class="headerlink" title="JVM如何解决类型擦除和多态的冲突？"></a><code>JVM</code>如何解决类型擦除和多态的冲突？</h2><p><code>JVM</code>为了解决类型擦除和多态的冲突，采用了特殊的方法：&#x3D;&#x3D;<strong>桥方法</strong>&#x3D;&#x3D;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T value;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T value)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DateInter</span> <span class="keyword">extends</span> <span class="title class_">Pair</span>&lt;Date&gt; &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Date value)</span> &#123;  </span><br><span class="line">        <span class="built_in">super</span>.setValue(value);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getValue();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上，代码经过编译后，<strong>编译器</strong>会自动给我们生成<strong>桥方法</strong>，<code>Pair&lt;T&gt;</code>经过泛型擦除后变成了原始类型，因为不做展示，让我们来看看子类<code>DateInter</code>,经过编译后是什么样子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DateInter</span> <span class="keyword">extends</span> <span class="title class_">Pair</span>&lt;Date&gt; &#123;  </span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Date value)</span> &#123;  </span><br><span class="line">        ...  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        ...  </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="comment">//以下两个方法就是编译器给我们生成的“桥方法”。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Object value)</span> &#123;  </span><br><span class="line">        setValue(value);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> getValue();  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，原本两个方法，编译之后成了四个方法，这多出来的方法就是<strong>桥方法</strong>，这个<strong>桥方法</strong>，不就相当于<strong>重写</strong>了父类的方法吗，实现了多态。</p><p>这就是 <strong>虚拟机巧妙的使用了桥方法，来解决了类型擦除和多态的冲突。</strong></p><p><font color="red" size= 5><strong>但是还是有一个问题：</strong></font></p><p><img src="/%5Cimage%5Carticle%5CJava%E6%B3%9B%E5%9E%8B%E6%9C%BA%E5%88%B6%EF%BC%88%E4%BA%8C%EF%BC%89%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%B3%9B%E5%9E%8B%5Cimage-20220811151617944.png" alt="image-20220811151617944"></p><p>当我们自己写代码时，两个方法的方法签名是一样的。这是不允许的，编译器无法通过，但为了解决<strong>类型擦除和多态的冲突</strong>，编译器却生成了他不允许的方法。</p><p>但实际上，<code>JVM </code>会用方法名、参数类型和返回类型来确定一个方法，所以针对方法签名相同的两个方法，返回值类型不相同的时候，<code>JVM</code>是能分辨的。</p><p>所以编译器为了实现泛型的多态允许自己做这个看起来“不合法”的事情，然后交给虚拟器去区别。</p><blockquote><p>方法签名：方法名+方法参数列表【重载过程中，使用方法签名可以唯一确定一个方法】</p></blockquote><p><font color="red" size=5><strong>还有一点需要说明的是</strong></font></p><p>这里面的<code>setValue</code>和<code>getValue</code>这两个<strong>桥方法</strong>的意义又有不同。</p><ul><li><p><code>setValue</code>方法是为了解决类型擦除与多态之间的冲突。</p></li><li><p><code>getValue</code>却有普遍的意义</p><p>如果这是一个普通的继承关系，那么父类的<code>getValue</code>方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.getValue();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而子类重写的方法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Date <span class="title function_">getValue</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.getValue();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这在普通的类继承中也是普遍存在的重写，这就是<strong>协变</strong>。</p></li></ul><p>参考:</p><ul><li>《java核心技术》</li><li><a href="https://pdai.tech/md/java/basic/java-basic-x-generic.html">https://pdai.tech/md/java/basic/java-basic-x-generic.html</a></li><li><a href="https://blog.csdn.net/qijingwang/article/details/119358511">https://blog.csdn.net/qijingwang/article/details/119358511</a></li><li><a href="https://blog.csdn.net/hao_yan_bing/article/details/89447792">https://blog.csdn.net/hao_yan_bing/article/details/89447792</a></li></ul>]]></content>
    
    
    <summary type="html">Java中的泛型是伪泛型？什么是类型擦除？如何证明类型擦除？什么是原始类型？如何理解编译器检查？JVM是如何解决类型擦除和多态之间的冲突的？</summary>
    
    
    
    <category term="java基础" scheme="http://example.com/category/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="泛型" scheme="http://example.com/tag/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java泛型机制（一）泛型基础</title>
    <link href="http://example.com/post/474fbc8a.html"/>
    <id>http://example.com/post/474fbc8a.html</id>
    <published>2022-08-09T07:54:25.000Z</published>
    <updated>2022-08-15T06:26:36.162Z</updated>
    
    <content type="html"><![CDATA[<h1 id="泛型概述"><a href="#泛型概述" class="headerlink" title="泛型概述"></a>泛型概述</h1><p>泛型程序设计  意味着  **编写的代码可以被很多不同类型的对象所<font color="red">重用</font>**！</p><p>Java泛型这个特性是从<code>JDK 1.5</code>开始的。因此为了兼容之前的版本，Java泛型的实现采取了“<strong>伪泛型</strong>”的策略，即Java在语法上支持泛型，但是在编译阶段会进行所谓的“<strong>类型擦除</strong>”（Type Erasure），将所有的泛型表示（尖括号中的内容）都替换为具体的类型（其对应的原生态类型），就像完全没有泛型一样。【类型擦除之后会讲解】。</p><p>其实，引入泛型的意义就是为了<strong>代码复用</strong></p><h2 id="为什么要使用泛型？"><a href="#为什么要使用泛型？" class="headerlink" title="为什么要使用泛型？"></a>为什么要使用泛型？</h2><p>泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，提高代码的重用率。</p><ul><li><p><strong>保证了类型的安全性【类型转换问题】</strong></p><p>在没有泛型之前，从集合中读取到的每一个对象都必须进行类型转换，如果不小心插入了错误的类型对象，在运行时的转换处理就会出错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();<span class="comment">//没有指定泛型，可以添加任何类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Object o : arrayList) &#123;</span><br><span class="line">    <span class="comment">//那当我们取的时候只能使用Object类型接收，那我们要是使用某个类型的方法时，我们需要进行强制类型转换</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) o;  <span class="comment">//你确定一定可以强制类型转换成功吗？</span></span><br><span class="line">    System.out.println(s.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="red"><strong>泛型中参数化类型不考虑继承关系</strong></font>的原因也就是因为如果考虑了继承关系，也就违背了泛型设计的初衷。</p><p>【详解见Java泛型机制（二）深入理解泛型——类型擦除】</p></li><li><p><strong>消除强制转换</strong></p><p>消除源代码中的许多强制类型转换，这使得代码更加可读，并且减少了出错机会。</p></li><li><p><strong>避免了不必要的装箱、拆箱操作，提高程序的性能</strong></p><p>在非泛型编程中，将筒单类型作为Object传递时会引起Boxing（装箱）和Unboxing（拆箱）操作，这两个过程都是具有很大开销的。引入泛型后，就不必进行Boxing和Unboxing操作了，所以运行效率相对较高，特别在对集合操作非常频繁的系统中，这个特点带来的性能提升更加明显。</p></li><li><p><strong>提高了代码的重用性。</strong></p></li></ul><h1 id="泛型的基本使用"><a href="#泛型的基本使用" class="headerlink" title="泛型的基本使用"></a>泛型的基本使用</h1><p>泛型有三种使用方式，分别为：</p><ul><li>泛型类</li><li>泛型接口</li><li>泛型方法。</li></ul><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Generi</span>&lt;T&gt; &#123;<span class="comment">//此处可以随便写标识符号，T是type的简称 </span></span><br><span class="line">    <span class="keyword">private</span> T str;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getStr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStr</span><span class="params">(T str)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.str = str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T aa)</span>&#123;</span><br><span class="line">        System.out.println(aa);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T,U&gt;&#123;<span class="comment">//多元泛型</span></span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> U second;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Info</span>&lt;T&gt;&#123;        <span class="comment">// 在接口上定义泛型  </span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getVar</span><span class="params">()</span> ; <span class="comment">// 定义抽象方法，抽象方法的返回值就是泛型类型  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InfoImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Info</span>&lt;T&gt;&#123;   <span class="comment">// 定义泛型接口的子类  </span></span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span> ;             <span class="comment">// 定义属性  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InfoImpl</span><span class="params">(T <span class="keyword">var</span>)</span>&#123;     <span class="comment">// 通过构造方法设置属性内容  </span></span><br><span class="line">        <span class="built_in">this</span>.setVar(<span class="keyword">var</span>) ;    </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVar</span><span class="params">(T <span class="keyword">var</span>)</span>&#123;  </span><br><span class="line">        <span class="built_in">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getVar</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.<span class="keyword">var</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Generi2</span> &#123;<span class="comment">//这个类并不是泛型类</span></span><br><span class="line">    <span class="comment">//泛型方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Generi2.&lt;String&gt;show(<span class="string">&quot;asda&quot;</span>);</span><br><span class="line">Generi2.show(<span class="string">&quot;asda&quot;</span>);<span class="comment">//&lt;String&gt;  可以省略</span></span><br></pre></td></tr></table></figure><hr><p>关于泛型方法定义：泛型方法可以定义在<strong>普通类</strong>中，也可以定义在<strong>泛型类</strong>中。</p><p>关于泛型方法调用：在调用泛型方法时，可以指定泛型，也可以不指定泛型:</p><p>先定义一个简单的泛型方法，通过演示看看<strong>指定泛型</strong>和<strong>不指定泛型</strong>的区别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是一个简单的泛型方法  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">add</span><span class="params">(T x,T y)</span>&#123;  </span><br><span class="line"><span class="keyword">return</span> y;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><ul><li><p>在不指定泛型的情况下，可以使用任意类型，但<strong>泛型变量的类型</strong>为该方法中的**几种类型的同一父类的<font color="red">最小级</font>**，直到Object</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Test.add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//这两个参数都是Integer，所以T为Integer类型  </span></span><br><span class="line"><span class="type">Number</span> <span class="variable">f</span> <span class="operator">=</span> Test.add(<span class="number">1</span>, <span class="number">1.2</span>); <span class="comment">//这两个参数一个是Integer，一个是Float，所以取同一父类的最小级，为Number  </span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> Test.add(<span class="number">1</span>, <span class="string">&quot;asd&quot;</span>); <span class="comment">//这两个参数一个是Integer，一个是String，所以取同一父类的最小级，为Object  </span></span><br></pre></td></tr></table></figure></li><li><p>在指定泛型的情况下，该方法的几种类型必须是**<font color="red">该泛型的实例的类型</font>或者<font color="red">其子类</font>**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Test.&lt;Integer&gt;add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//指定了Integer，所以只能为Integer类型或者其子类  </span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Test.&lt;Integer&gt;add(<span class="number">1</span>, <span class="number">2.2</span>); <span class="comment">//编译错误，指定了Integer，不能为Float  </span></span><br><span class="line"><span class="type">Number</span> <span class="variable">c</span> <span class="operator">=</span> Test.&lt;Number&gt;add(<span class="number">1</span>, <span class="number">2.2</span>); <span class="comment">//指定为Number，所以可以为Integer和Float </span></span><br></pre></td></tr></table></figure></li></ul><hr><p>完整示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">/**不指定泛型的时候*/</span>  </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Test.add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//这两个参数都是Integer，所以T为Integer类型  </span></span><br><span class="line">        <span class="type">Number</span> <span class="variable">f</span> <span class="operator">=</span> Test.add(<span class="number">1</span>, <span class="number">1.2</span>); <span class="comment">//这两个参数一个是Integer，一个是Float，所以取同一父类的最小级，为Number  </span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> Test.add(<span class="number">1</span>, <span class="string">&quot;asd&quot;</span>); <span class="comment">//这两个参数一个是Integer，一个是String，所以取同一父类的最小级，为Object  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**指定泛型的时候*/</span>  </span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Test.&lt;Integer&gt;add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//指定了Integer，所以只能为Integer类型或者其子类  </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Test.&lt;Integer&gt;add(<span class="number">1</span>, <span class="number">2.2</span>); <span class="comment">//编译错误，指定了Integer，不能为Float  </span></span><br><span class="line">        <span class="type">Number</span> <span class="variable">c</span> <span class="operator">=</span> Test.&lt;Number&gt;add(<span class="number">1</span>, <span class="number">2.2</span>); <span class="comment">//指定为Number，所以可以为Integer和Float  </span></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//这是一个简单的泛型方法  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">add</span><span class="params">(T x,T y)</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> y;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类型限定"><a href="#类型限定" class="headerlink" title="类型限定"></a>类型限定</h1><p><strong>先看一个例子</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>B是A的子类。然后定义一个方法<code>funA(A a)</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">funA</span><span class="params">(A a)</span> &#123;</span><br><span class="line">    <span class="comment">// ...          </span></span><br><span class="line">&#125;</span><br><span class="line">funA(A);</span><br><span class="line">funA(B);</span><br></pre></td></tr></table></figure><p>以上两个调用都不会报错。那再定义一个方法<code>funA(List&lt;A&gt; listA)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">funC</span><span class="params">(List&lt;A&gt; listA)</span> &#123;</span><br><span class="line">    <span class="comment">// ...          </span></span><br><span class="line">&#125;</span><br><span class="line">funA(<span class="keyword">new</span> <span class="title class_">List</span>&lt;A&gt;);</span><br><span class="line">funA(<span class="keyword">new</span> <span class="title class_">List</span>&lt;B&gt;);  <span class="comment">//很明显会报错 为什么呢？先说如何解决</span></span><br></pre></td></tr></table></figure><p><font color="blue" size=5><strong>如何解决？</strong></font></p><p>泛型设计初衷之一就是为了解决<strong>类型转换</strong>问题，泛型中参数化类型不考虑继承关系【不允许类型转换】，但有的时候也确实需要进行类型转换。</p><p>为了解决泛型中<strong>隐含的类型转换问题</strong>，Java泛型加入了<strong>类型参数</strong>的&#x3D;&#x3D;<strong>上下边界机制</strong>&#x3D;&#x3D;。【<font color="red">注意是<strong>类型参数</strong></font>】，为类型参数添加限制的同时，对类和对象的使用也添加了限制ˋ( ° ▽、° )。详情见下 </p><p><code>&lt;? extends A&gt;</code>表示该类型参数可以是<strong>A(上边界)<strong>或者</strong>A的子类类型</strong>。你可以这样理解，【对于<code>? extends A</code>，该类型参数须是<strong>继承了A</strong>。】编译时擦除到类型A，即用A类型代替类型参数。</p><p>使用<code>&lt;? extends A&gt;</code>可以解决以上的问题</p><p>​编译器知道了类型参数的范围—&gt;如果传入的实例类型B是在这个范围内的话—&gt;允许转换</p><p>​这时只要一次类型转换就可以了，运行时会把对象当做A的实例看待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">funC</span><span class="params">(List&lt;? extends A&gt; listA)</span> &#123;</span><br><span class="line">    <span class="comment">// ...          </span></span><br><span class="line">&#125;</span><br><span class="line">funA(<span class="keyword">new</span> <span class="title class_">List</span>&lt;A&gt;);</span><br><span class="line">funA(<span class="keyword">new</span> <span class="title class_">List</span>&lt;B&gt;);  <span class="comment">//这样就不会报错</span></span><br></pre></td></tr></table></figure><p><font color="blue" size=5><strong>为什么会报错？</strong></font></p><p>类B是类A的子类。A是B的父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">funC</span><span class="params">(List&lt;A&gt; listA)</span> &#123;</span><br><span class="line">    <span class="comment">// ...          </span></span><br><span class="line">&#125;</span><br><span class="line">funA(<span class="keyword">new</span> <span class="title class_">List</span>&lt;B&gt;);  <span class="comment">//报错</span></span><br></pre></td></tr></table></figure><p>这相当于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;A&gt; listA = new List&lt;B&gt;; </span><br></pre></td></tr></table></figure><p>假如这样不会报错····当我们从<code>listA</code>取值时，都是A类型。B类型转换为A类型【子类向上转型为父类，这是Java允许的】。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B element = (B)listA.get(0);</span><br></pre></td></tr></table></figure><p>但这样做是没有意义的，这违背了泛型的初衷——<strong>解决类型转换问题</strong>。就像</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;;<span class="comment">//这是Java不允许的。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String)list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>我们使用了泛型，到头来，还是要自己强转，违背了泛型设计的初衷。所以<code>java</code>不允许这么干。</p><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p>常用的通配符有： <code>T，E，K，V，?</code></p><p>其实也可以是A、B、C、D、E等的字母代替。使用 <code>T，E，K，V，?</code>只不过是约定俗成而已。</p><p><code>T，E，K，V，?</code>  的约定如下：</p><p><code>T</code>：(type) 表示具体的一个<code>java</code>类型。</p><p><code>E</code>：代表Element。</p><p><code>K、V</code> ：分别代表<code>java</code>键值中的Key Value。</p><p><code>?</code> ：无界通配符，表示不确定的 <code>java</code> 类型</p><h2 id="上下限"><a href="#上下限" class="headerlink" title="上下限"></a>上下限</h2><p>在使用泛型的时候，我们可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类</p><ul><li><code>&lt;?&gt;</code> 无限制通配符</li><li><code>&lt;? extends E&gt;</code>     <code>extends</code> 关键字声明了<strong>类型的上界</strong>，表示参数化的类型可能是所指定的类型，或者是&#x3D;&#x3D;此类型的<strong>子类</strong>&#x3D;&#x3D;</li><li><code>&lt;? super E&gt;</code>        <code>super</code> 关键字声明了<strong>类型的下界</strong>，表示参数化的类型可能是指定的类型，或者是&#x3D;&#x3D;此类型的<strong>父类</strong>&#x3D;&#x3D;</li></ul><p>使用原则《Effictive Java》<br>为了获得最大限度的灵活性，要在表示 生产者或者消费者 的&#x3D;&#x3D;<strong>输入参数</strong>&#x3D;&#x3D;上使用通配符，使用的规则就是：生产者有上限、消费者有下限</p><ol><li>如果参数化类型表示一个 T 的生产者，使用 &lt; ? extends T&gt;;</li><li>如果它表示一个 T 的消费者，就使用 &lt; ? super T&gt;；</li><li>如果既是生产又是消费，那使用通配符就没什么意义了，因为你需要的是精确的参数类型。</li></ol><p><font size=4><strong>上边界限定通配符 &lt; ? extends E&gt;</strong></font></p><p><code>&lt;T extends BoundingType&gt;</code>表示<code>T</code>应该是<code>BoundingType</code>的子类型。T和<code>BoundingType</code>可以是类，也可以是接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Double&gt; doubleList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        doubleList.add(<span class="number">1.2</span>);</span><br><span class="line">        doubleList.add(<span class="number">3.13</span>);</span><br><span class="line">        show(doubleList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(List&lt;? extends Number&gt; list)</span>&#123;<span class="comment">//参数类型 必须是Number的子类</span></span><br><span class="line"><span class="comment">//        list.add(10.1);</span></span><br><span class="line">        <span class="keyword">for</span> (Number number : list) &#123;</span><br><span class="line">            System.out.println(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上代码可以看出，参数被限定为泛型必须是Number的子类。<font color="red" size= 5><strong>可以取出，但是不能添加</strong></font></p><p><img src="/%5Cimage%5Carticle%5CJava%E6%B3%9B%E5%9E%8B%E6%9C%BA%E5%88%B6%EF%BC%88%E4%B8%80%EF%BC%89%E6%B3%9B%E5%9E%8B%E5%9F%BA%E7%A1%80%5Cimage-20220809181958588.png" alt="image-20220809181958588"></p><ul><li><p>为什么不能添加呢？</p><p>因为，List中的元素都是Number的子类。</p><p>如果list的泛型是<code>Integer</code>类型，此时你去添加<code>Integer</code>类型的没问题。</p><p>如果list的泛型是<code>Double</code>类型，此时你去添加<code>Double</code>类型的没问题。</p><p>但是，现在不确定是什么类型的，只知道他是Number的子类，就能添加。</p><p>如果list是<code>Integer</code>类型的,那就不能添加除<code>Integer</code>之外的，那如果是<code>Double</code>呢，也一样，所以就全都不能添加啦。</p></li><li><p>那为什么可以取出呢？</p><p>因为我们从list中拿出来的必定是<code>Number</code>类型的，毕竟<code>Integer</code>等都去继承<code>Number</code>了，可以自动<strong>向上转型</strong></p></li></ul><p><font size=4><strong>下边界限定通配符 &lt; ? super E&gt;</strong></font></p><p>又叫<u>超类型通配符</u>。与extends特性完全相反。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; integerList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(List&lt;? <span class="built_in">super</span> Integer&gt; list)</span>&#123;</span><br><span class="line">        list.add(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与上限相反，<font color="red" size= 5><strong>可以添加，但是不能取出</strong></font></p><ul><li><p>为什么可以添加？</p><p>这里定义了下限是<code>Integer</code>,也就是说这个list里面的类型都是<code>Integer</code>的父类，所以我们只能添加<code>Integer</code>和他的父类。</p></li><li><p>为什么不能取出？</p><p>因为取的时候没法确实是<code>Interger</code>的哪个父类【没法向上转型】,最后都只能获取我们的根类<code>Object</code></p></li></ul><blockquote><p>还要说一句的是，如果既没有上限也没有下限，就既不能取出也不能添加。取出只能用根类<code>Object</code>接收，因为取出根本不知道什么类型的。里面是什么类型不知道，所以就不能放进去。</p></blockquote><h2 id="实际例子"><a href="#实际例子" class="headerlink" title="实际例子"></a>实际例子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>  &lt;E <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> E&gt;&gt; E <span class="title function_">max</span><span class="params">(List&lt;? extends E&gt; e1)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e1 == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//迭代器返回的元素属于 E 的某个子类型</span></span><br><span class="line">    Iterator&lt;? <span class="keyword">extends</span> <span class="title class_">E</span>&gt; iterator = e1.iterator();</span><br><span class="line">    <span class="type">E</span> <span class="variable">result</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        <span class="type">E</span> <span class="variable">next</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        <span class="keyword">if</span> (next.compareTo(result) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            result = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有三处类型限定泛型：</p><ul><li><p><code>Comparable&lt;? super E&gt;</code></p><p>要对 E 进行比较，即 E 的消费者，所以需要用 super</p></li><li><p><code>List&lt;? extends E&gt;</code></p><p>我们要操作的数据的<code>E</code>，需要<strong>取出</strong>进行比较，所以使用<code>extends</code>。</p></li><li><p><code>&lt;E extends Comparable&lt;? super E&gt;&gt;</code></p><p>要进行比较，所以 E 需要是可比较的类，因此需要 <code>extends Comparable&lt;…&gt;</code></p></li></ul><h2 id="多个限制"><a href="#多个限制" class="headerlink" title="多个限制"></a>多个限制</h2><p>使用&amp;符号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="comment">//工资低于2500元的上斑族并且站立的乘客车票打8折</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Staff</span> &amp; Passenger&gt; <span class="keyword">void</span> <span class="title function_">discount</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t.getSalary()&lt;<span class="number">2500</span> &amp;&amp; t.isStanding())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;恭喜你！您的车票打八折！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        discount(<span class="keyword">new</span> <span class="title class_">Me</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="https://pdai.tech/md/java/basic/java-basic-x-generic.html">https://pdai.tech/md/java/basic/java-basic-x-generic.html</a></p><p><a href="https://blog.csdn.net/weixin_40251892/article/details/109063161">https://blog.csdn.net/weixin_40251892/article/details/109063161</a></p><p><a href="https://www.cnblogs.com/qinjunlin/p/14721362.html">https://www.cnblogs.com/qinjunlin/p/14721362.html</a></p><p><a href="https://blog.csdn.net/qq_41701956/article/details/123473592">https://blog.csdn.net/qq_41701956/article/details/123473592</a></p><p>《Java核心技术卷一》</p>]]></content>
    
    
    <summary type="html">泛型概述、泛型的基本使用以及泛型的类型限定</summary>
    
    
    
    <category term="java基础" scheme="http://example.com/category/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="泛型" scheme="http://example.com/tag/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>直线上最多的点</title>
    <link href="http://example.com/post/d98be659.html"/>
    <id>http://example.com/post/d98be659.html</id>
    <published>2022-08-09T03:00:52.000Z</published>
    <updated>2022-08-09T03:46:20.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个数组 <code>points</code> ，其中 <code>points[i] = [xi, yi]</code> 表示 <strong>X-Y</strong> 平面上的一个点。求最多有多少个点在同一条直线上【难度：<font color="red"><strong>困难</strong></font>】</p><p><strong>示例：</strong></p><p><img src="/%5Cimage%5Carticle%5C%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B9%5Cimage-20220809110414951.png" alt="image-20220809110414951"></p><blockquote><p>输入：points &#x3D; [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]<br>输出：4</p></blockquote><p>提示：</p><ul><li>1 &lt;&#x3D; <code>points.length</code> &lt;&#x3D; 300</li><li><code>points[i].length</code> &#x3D;&#x3D; 2</li><li>-10^4 &lt;&#x3D; <code>xi, yi</code> &lt;&#x3D; 10^4</li><li><code>points</code> 中的所有点 互不相同</li></ul><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/max-points-on-a-line">https://leetcode.cn/problems/max-points-on-a-line</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>枚举所有的点，假设直线经过该点时，该直线所能经过的最多的点数。</p><p>假设我们当前枚举到点<code> i</code>，如果直线同时经过另外两个不同的点<code> j</code> 和<code> k</code>，那么可以发现点 <code>i</code> 和点 <code>j</code> 所连直线的斜率恰等于点<code> i</code> 和点 <code>k</code> 所连直线的斜率。</p><p>于是我们可以统计其他所有点与点 <code>i</code> 所连直线的斜率，出现次数最多的斜率即为经过点数最多的直线的斜率，其经过的点数为该斜率现的次数加一（点 <code>i</code> 自身也要被统计）。</p><img src="\image\article\直线上最多的点\IMG_0411(20220809-111214).PNG" alt="IMG_0411(20220809-111214)" style="zoom: 33%;" /><p><font color="blue"><strong>关键是这个斜率如何表示？</strong></font></p><p>需要注意的是，<strong>浮点数类型可能因为精度不够而无法足够精确地表示每一个斜率</strong>，因此我们需要换一种方法来记录斜率。</p><p>斜率可以表示为 $$\frac{\bigtriangleup x}{\bigtriangleup y}$$,因此我们可以用分子和分母组成的二元组来代表斜率。我们可以分为以下几种情况：</p><ul><li><p>形如$$\frac{1}{2}和\frac{2}{4}$$这种情况</p><p>虽然这样的二元组不同，但其斜率是相同的。因此我们可以将<strong>分子</strong>和<strong>分母</strong>同时除以二者绝对值的<strong>最大公约数</strong>。</p><p>求最大公约数可以使用<font color="red"><strong>欧几里得算法</strong></font>【即辗转相除法】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b!=<span class="number">0</span>?gcd(b,a%b):a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>比如：a &#x3D; 63,b&#x3D;27;【要保证a是大于b的】</p><p>① b!&#x3D;0  –&gt; a &#x3D; 27,b&#x3D; 63%27 &#x3D; 9;</p><p>②b!&#x3D;0   –&gt; a &#x3D; 9,b &#x3D; 27%9 &#x3D; 0;</p><p>③b&#x3D;&#x3D;0  –&gt; 返回 a&#x3D;9; </p></blockquote></li><li><p>形如$$\frac{-1}{2}和\frac{1}{-2}$$这种情况</p><p>对于这种情况，可以规定。<strong>当分母为负数时，分子和分母取反。</strong>这样可以保证，分母都是正数，分子是同号的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(y&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    x = -x;y=-y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>x和y中有一个为0的情况</p><p>此时两数不存在数学意义上的最大公约数，因此我们直接特判这两种情况。当 <code>x==0</code> 时，我们令 y&#x3D;1；当 <code>y==0</code>时，我们令 x&#x3D;1 即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(x==<span class="number">0</span>)&#123;</span><br><span class="line">    y=<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(y==<span class="number">0</span>)&#123;</span><br><span class="line">    x=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>经过上述操作之后，即可得到最终的二元组<code>(x,y)</code>。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPoints</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">            Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            当我们枚举到点 i 时，我们只需要考虑编号大于 i 的点到点 i 的斜率，因为如果直线同时经过编号小于点 i 的点 j，那 么当我们枚举到 j 时就已经考虑过该直线了；</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; points.length; j++) &#123;</span><br><span class="line">                <span class="comment">// 计算 二元组 x,y</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> points[i][<span class="number">0</span>]-points[j][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> points[i][<span class="number">1</span>]-points[j][<span class="number">1</span>];</span><br><span class="line">                <span class="comment">//分三种情况讨论，二元组</span></span><br><span class="line">                <span class="keyword">if</span>(x==<span class="number">0</span>)&#123;                  <span class="comment">//x==0</span></span><br><span class="line">                    y=<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(y==<span class="number">0</span>)&#123;             <span class="comment">//y==0</span></span><br><span class="line">                    x=<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;                     <span class="comment">//x!=0&amp;&amp;y!=0</span></span><br><span class="line">                    <span class="keyword">if</span>(y&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                        x = -x;y=-y;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">gcd</span> <span class="operator">=</span> gcd(Math.abs(x),Math.abs(y)); <span class="comment">//求最大公约数</span></span><br><span class="line">                    x = x/gcd;</span><br><span class="line">                    y = y/gcd;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> x*<span class="number">20001</span>+y;        <span class="comment">//计算哈希表的键</span></span><br><span class="line">                map.put(val,map.getOrDefault(val,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//计算这次循环中，直线最大的点数</span></span><br><span class="line">            Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : entrySet) &#123;</span><br><span class="line">                num = Math.max(num,entry.getValue()+<span class="number">1</span>);<span class="comment">//这个entry.getValue()+1表示点 i 自身也要被统计</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            res = Math.max(res,num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b!=<span class="number">0</span>?gcd(b,a%b):a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此基础上，我们还可以做如下<font color="red"><strong>优化</strong></font></p><ul><li><p>在点的总数量小于等于 2 的情况下，我们总可以用一条直线将所有点串联，此时我们直接返回点的总数量即可；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(points.length&lt;=<span class="number">2</span>)<span class="keyword">return</span> points.length;</span><br></pre></td></tr></table></figure></li><li><p>当我们找到<strong>一条直线上的点数</strong>经过了<strong>图中超过半数的点</strong>时，我们即可以确定该直线即为经过最多点的直线；</p></li><li><p>当我们枚举到点 i（假设编号从 0 开始）时，我们至多只能找到<code> n - i</code>个点共线。假设此前找到的共线的点的数量的最大值为 k，如果有 <code>k＞= n - i</code>，那么此时我们即可停止枚举，因为不可能再找到更大的答案了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (res &gt;= n - i || res &gt; n / <span class="number">2</span>) <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></li></ul><h1 id="题解代码"><a href="#题解代码" class="headerlink" title="题解代码"></a>题解代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPoints</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(points.length&lt;=<span class="number">2</span>)<span class="keyword">return</span> points.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(res&gt;=points.length-i||res&gt;points.length/<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; points.length; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> points[i][<span class="number">0</span>]-points[j][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> points[i][<span class="number">1</span>]-points[j][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(x==<span class="number">0</span>)&#123;</span><br><span class="line">                    y=<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(y==<span class="number">0</span>)&#123;</span><br><span class="line">                    x=<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(y&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                        x = -x;y=-y;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">gcd</span> <span class="operator">=</span> gcd(Math.abs(x),Math.abs(y));</span><br><span class="line">                    x = x/gcd;</span><br><span class="line">                    y = y/gcd;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> x*<span class="number">20001</span>+y;</span><br><span class="line">                System.out.println(val+<span class="string">&quot;  &quot;</span>+x+<span class="string">&quot;  &quot;</span>+y);</span><br><span class="line">                map.put(val,map.getOrDefault(val,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : entrySet) &#123;</span><br><span class="line">                num = Math.max(num,entry.getValue()+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res,num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b!=<span class="number">0</span>?gcd(b,a%b):a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">使用哈希表来计算直线上最多的点，其中使用了欧几里得算法求最大公约数</summary>
    
    
    
    <category term="算法" scheme="http://example.com/category/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="直线上最多的点&amp;求最大公约数" scheme="http://example.com/tag/%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B9-%E6%B1%82%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot发送邮件</title>
    <link href="http://example.com/post/f5937762.html"/>
    <id>http://example.com/post/f5937762.html</id>
    <published>2022-08-08T06:15:43.000Z</published>
    <updated>2022-08-08T14:21:56.086Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下，Spring Boot如何发送邮件。分为以下五种</p><ul><li>发送文本邮件</li><li>发送html邮件</li><li>发送附件邮件</li><li>发送图片邮件</li><li>发送模板邮件</li></ul><h1 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h1><p>引入maven坐标。<code>spring-boot-starter-mail</code>、<code>spring-boot-starter-thymeleaf</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--模板引擎--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--模板引擎--&gt;</span></span><br></pre></td></tr></table></figure><p>配置配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mail:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">smtp.qq.com</span> <span class="comment">#smtp.126.com</span></span><br><span class="line">    <span class="attr">username:</span> <span class="number">928301810</span><span class="string">@qq.com</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">····</span> <span class="comment">#POP3授权码</span></span><br><span class="line">    <span class="attr">default-encoding:</span> <span class="string">UTF-8</span></span><br></pre></td></tr></table></figure><p>这里的password，并不是你邮箱的登录密码，而是POP3授权码。</p><h2 id="配置邮箱（以qq邮箱为例）"><a href="#配置邮箱（以qq邮箱为例）" class="headerlink" title="配置邮箱（以qq邮箱为例）"></a>配置邮箱（以qq邮箱为例）</h2><p>点击邮箱的设置，然后点击账户</p><p><img src="/%5Cimage%5Carticle%5CSpringBoot%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%5Cimage-20220808212318162.png" alt="image-20220808212318162"></p><p>将获取的POP3授权码，设置到配置文件中。</p><h1 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h1><p>注入<code>JavaMailSender</code>对象，这是一个接口。然后获取配置文件中<code>username</code>配置信息。作为发送方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;spring.mail.username&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String from;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JavaMailSender sender;</span><br></pre></td></tr></table></figure><h2 id="发送文本文件"><a href="#发送文本文件" class="headerlink" title="发送文本文件"></a>发送文本文件</h2><p>Service层</p><p>这里先用<code>SimpleMailMessage</code>对象，封装消息，包括：发送方，接收方、邮件主题、邮件内容。</p><p>然后使用<code>JavaMailSender</code>对象，发送消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.mail.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JavaMailSender sender;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendmail</span><span class="params">(String to, String subject, String content)</span> &#123;</span><br><span class="line">        <span class="type">SimpleMailMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMailMessage</span>();</span><br><span class="line">        message.setTo(to);</span><br><span class="line">        message.setSubject(subject);</span><br><span class="line">        message.setText(content);</span><br><span class="line">        message.setFrom(from);</span><br><span class="line"></span><br><span class="line">        sender.send(message);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">    service.sendmail(<span class="string">&quot;928301810@qq.com&quot;</span>,<span class="string">&quot;HELLO&quot;</span>,<span class="string">&quot;这是我用SrongBoot发送的第一封邮件&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>to：收件方</li><li>subject：邮件主题</li><li>content：邮件内容</li></ul><h2 id="发送html文件"><a href="#发送html文件" class="headerlink" title="发送html文件"></a>发送html文件</h2><p>Service层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.mail.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JavaMailSender sender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendhtml</span><span class="params">(String to, String subject, String content)</span> <span class="keyword">throws</span> MessagingException &#123;</span><br><span class="line">        <span class="type">MimeMessage</span> <span class="variable">message</span> <span class="operator">=</span> sender.createMimeMessage();</span><br><span class="line">        <span class="type">MimeMessageHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessageHelper</span>(message,<span class="literal">true</span>);</span><br><span class="line">        helper.setFrom(from);</span><br><span class="line">        helper.setTo(to);</span><br><span class="line">        helper.setSubject(subject);</span><br><span class="line">        helper.setText(content,<span class="literal">true</span>);</span><br><span class="line">        sender.send(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是使用<code>JavaMailSender</code>的<code>createMimeMessage</code>方法，来获取<code>MimeMessage</code>对象。</p><p><code>MimeMessageHelper</code>的构造方法的两个参数，一个是<code>message</code>，另一个是<code>true</code>。</p><p>true表示发送的邮件是<code>multipart邮件</code>。简单来说，<code>multpart</code>是一种可以内嵌html，包含附件的邮件类型。</p><p>然后测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">TestSendHTML</span><span class="params">()</span> <span class="keyword">throws</span> MessagingException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;&lt;html&gt;\n&quot;</span>+</span><br><span class="line">            <span class="string">&quot;&lt;body&gt;\n&quot;</span>+</span><br><span class="line">            <span class="string">&quot;&lt;h3&gt;这是我用SrongBoot发送的第二封邮件&lt;/h3&gt;\n&quot;</span>+</span><br><span class="line">            <span class="string">&quot;&lt;/body&gt;\n&quot;</span>+</span><br><span class="line">            <span class="string">&quot;&lt;/html&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    service.sendhtml(<span class="string">&quot;928301810@qq.com&quot;</span>,<span class="string">&quot;HELLO&quot;</span>,content);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="发送带附件的邮件"><a href="#发送带附件的邮件" class="headerlink" title="发送带附件的邮件"></a>发送带附件的邮件</h2><p>Service层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.mail.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JavaMailSender sender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendhtmlwithFile</span><span class="params">(String to, String subject, String content, String[] filepaths)</span> <span class="keyword">throws</span> MessagingException, FileNotFoundException &#123;</span><br><span class="line">        <span class="type">MimeMessage</span> <span class="variable">message</span> <span class="operator">=</span> sender.createMimeMessage();</span><br><span class="line">        <span class="type">MimeMessageHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessageHelper</span>(message,<span class="literal">true</span>);</span><br><span class="line">        helper.setFrom(from);</span><br><span class="line">        helper.setTo(to);</span><br><span class="line">        helper.setSubject(subject);</span><br><span class="line">        helper.setText(content,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String filepath : filepaths) &#123;</span><br><span class="line">            <span class="type">FileSystemResource</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemResource</span>(<span class="keyword">new</span> <span class="title class_">File</span>(filepath));</span><br><span class="line">            <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> file.getFilename();</span><br><span class="line">            <span class="keyword">assert</span> filename != <span class="literal">null</span>;</span><br><span class="line">            helper.addAttachment(filename,file);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sender.send(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从参数<code>String[] filepaths</code>,可以看出，它是可以携带多个附件的。与发送html不同的是，多了如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String filepath : filepaths) &#123;</span><br><span class="line">    <span class="type">FileSystemResource</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemResource</span>(<span class="keyword">new</span> <span class="title class_">File</span>(filepath));</span><br><span class="line">    <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> file.getFilename();</span><br><span class="line">    <span class="keyword">assert</span> filename != <span class="literal">null</span>;</span><br><span class="line">    helper.addAttachment(filename,file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">TestSendwithFile</span><span class="params">()</span> <span class="keyword">throws</span> MessagingException, FileNotFoundException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;&lt;html&gt;\n&quot;</span>+</span><br><span class="line">            <span class="string">&quot;&lt;body&gt;\n&quot;</span>+</span><br><span class="line">            <span class="string">&quot;&lt;h3&gt;这是我用SrongBoot发送的第三封带附件的邮件&lt;/h3&gt;\n&quot;</span>+</span><br><span class="line">            <span class="string">&quot;&lt;/body&gt;\n&quot;</span>+</span><br><span class="line">            <span class="string">&quot;&lt;/html&gt;&quot;</span>;</span><br><span class="line">    String[] filepaths = &#123;<span class="string">&quot;C:\\Users\\TJS\\Desktop\\力扣算法题链接.md&quot;</span>, <span class="string">&quot;C:\\Users\\TJS\\Desktop\\nginx-1.16.1.tar.gz&quot;</span>&#125;;</span><br><span class="line">    service.sendhtmlwithFile(<span class="string">&quot;928301810@qq.com&quot;</span>,<span class="string">&quot;HELLO&quot;</span>,content, filepaths);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="发送带有图片的邮件"><a href="#发送带有图片的邮件" class="headerlink" title="发送带有图片的邮件"></a>发送带有图片的邮件</h2><p>Service层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.mail.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JavaMailSender sender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendImage</span><span class="params">(String to, String subject, String content,String[][] images)</span> <span class="keyword">throws</span> MessagingException &#123;</span><br><span class="line">        <span class="type">MimeMessage</span> <span class="variable">message</span> <span class="operator">=</span> sender.createMimeMessage();</span><br><span class="line">        <span class="type">MimeMessageHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessageHelper</span>(message,<span class="literal">true</span>);</span><br><span class="line">        helper.setFrom(from);</span><br><span class="line">        helper.setTo(to);</span><br><span class="line">        helper.setSubject(subject);</span><br><span class="line">        helper.setText(content,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String[] image : images) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> image[<span class="number">0</span>];</span><br><span class="line">            <span class="type">String</span> <span class="variable">rscId</span> <span class="operator">=</span> image[<span class="number">1</span>];</span><br><span class="line">            <span class="type">FileSystemResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemResource</span>(<span class="keyword">new</span> <span class="title class_">File</span>(path));</span><br><span class="line">            helper.addInline(rscId,resource);</span><br><span class="line">        &#125;</span><br><span class="line">        sender.send(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以内嵌多张图片，传入images字符串数组。</p><p><code>images[i][0]</code>：图片的路径，可以是绝对路径，也可以是相对路径。</p><p><code>images[i][1]</code>：图片的id。因为它内嵌到邮件中，实际就是以html的方式内嵌到邮件中，因此需要使用<code>&lt;img&gt;</code>标签</p><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">TestSendImage</span><span class="params">()</span> <span class="keyword">throws</span> MessagingException &#123;</span><br><span class="line">    String[][]  images = <span class="keyword">new</span> <span class="title class_">String</span>[][]&#123;</span><br><span class="line">            &#123;<span class="string">&quot;src/main/resources/static/2.JPG&quot;</span>,<span class="string">&quot;002&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;src/main/resources/static/3.JPG&quot;</span>,<span class="string">&quot;003&quot;</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">content</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;&lt;html&gt;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;&lt;body&gt;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;&lt;h3&gt;这是我用SrongBoot发送的第四封带图片的邮件&lt;/h3&gt;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//-------------------------------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">for</span> (String[] image : images) &#123;</span><br><span class="line">        content.append(<span class="string">&quot;&lt;img src=&#x27;cid:&quot;</span>).append(image[<span class="number">1</span>]).append(<span class="string">&quot;&#x27;&gt;&lt;/img&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//&lt;img src=&quot;cid:image[1]&quot;&gt;&lt;/img&gt;</span></span><br><span class="line">    <span class="comment">//----------------------------------------------------------------------------------</span></span><br><span class="line">    </span><br><span class="line">    content.append(<span class="string">&quot;&lt;/body&gt;\n&quot;</span>+ <span class="string">&quot;&lt;/html&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    service.sendImage(<span class="string">&quot;928301810@qq.com&quot;</span>,<span class="string">&quot;HELLO&quot;</span>, content.toString(),images);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="发送模板邮件"><a href="#发送模板邮件" class="headerlink" title="发送模板邮件"></a>发送模板邮件</h1><p>生活中有很多场景特别适用模板邮件，比如：</p><ul><li>用户注册</li><li>忘记密码</li></ul><p>这些邮件都有一个特点：邮件的主体内容不会变化，变化的是用户的信息。在这个使用的模板引擎是：<code>thymeleaf</code>。</p><p>maven坐标已经再前面引入。service层使用发送html的就可以。</p><p>然后再resouce的templates文件夹中，创建html模板。</p><img src="\image\article\SpringBoot发送邮件\image-20220808215552489.png" alt="image-20220808215552489" style="zoom:80%;" /><p>html代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--声明thymeleaf--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    必须闭合 meta标签--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>邮件模板<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    您好，感谢您的注册，这是一封验证邮件，请点击下面的链接完成注册，感谢您的支持！</span><br><span class="line">    <span class="comment">&lt;!--/*@thymesVar id=&quot;id&quot; type=&quot;java&quot;*/--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;http://www.ityouknow.com/register/&#123;id&#125;(id=$&#123;id&#125;)&#125;&quot;</span>&gt;</span>激活账号<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以看到只有<code>id</code>是变化的。<code>&#123;id&#125;(id=$&#123;id&#125;)</code></p><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpringbootMailApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MailService service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TemplateEngine templateEngine;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">TestTemplete</span><span class="params">()</span> <span class="keyword">throws</span> MessagingException &#123;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();</span><br><span class="line">        context.setVariable(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;006&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">emailTemplate</span> <span class="operator">=</span> templateEngine.process(<span class="string">&quot;EmailTemplate&quot;</span>, context);</span><br><span class="line">        service.sendhtml(<span class="string">&quot;928301810@qq.com&quot;</span>,<span class="string">&quot;HELLO&quot;</span>,emailTemplate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要注入<code>TemplateEngine</code>来解析html模板。</p><p>创建Context对象，来封装变量。然后使用<code>TemplateEngine</code>来解析模板，因此需要传入<code>Context</code>对象。</p><h1 id="关于异常的处理"><a href="#关于异常的处理" class="headerlink" title="关于异常的处理"></a>关于异常的处理</h1><p>我们看到，在发送邮件过程中，会产生例如<code>MessagingException</code>异常。我们处理的方法是不断的向外抛。</p><p>但在项目中的操作通常是一个异步的操作，因此它不必要去影响主业务。因此这个异常需要我们自己来处理，而不是统统抛出去。这种情况下，我们需要使用Log，以日志的形式记录下来。</p><p>以发送HTML邮件的代码为例，原代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.mail.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JavaMailSender sender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendhtml</span><span class="params">(String to, String subject, String content)</span> <span class="keyword">throws</span> MessagingException &#123;</span><br><span class="line">        <span class="type">MimeMessage</span> <span class="variable">message</span> <span class="operator">=</span> sender.createMimeMessage();</span><br><span class="line">        <span class="type">MimeMessageHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MimeMessageHelper</span>(message,<span class="literal">true</span>);</span><br><span class="line">        helper.setFrom(from);</span><br><span class="line">        helper.setTo(to);</span><br><span class="line">        helper.setSubject(subject);</span><br><span class="line">        helper.setText(content,<span class="literal">true</span>);</span><br><span class="line">        sender.send(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>try···catch</code>来捕获异常，并记录日志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="built_in">this</span>.getClass());<span class="comment">//日志对象</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.mail.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JavaMailSender sender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendhtml</span><span class="params">(String to, String subject, String content)</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;发送静态邮件开始,接收方&#123;&#125;,&#123;&#125;&quot;</span>,to,subject);</span><br><span class="line">        <span class="type">MimeMessage</span> <span class="variable">message</span> <span class="operator">=</span> sender.createMimeMessage();</span><br><span class="line">        <span class="type">MimeMessageHelper</span> <span class="variable">helper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            helper = <span class="keyword">new</span> <span class="title class_">MimeMessageHelper</span>(message,<span class="literal">true</span>);</span><br><span class="line">            helper.setFrom(from);</span><br><span class="line">            helper.setTo(to);</span><br><span class="line">            helper.setSubject(subject);</span><br><span class="line">            helper.setText(content,<span class="literal">true</span>);</span><br><span class="line">            sender.send(message);</span><br><span class="line">            logger.info(<span class="string">&quot;发送成功！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MessagingException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;发送失败,&#123;&#125;&quot;</span>,e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><ul><li>421 HL:ICC该IP同时并发连接数过大</li><li>451 Requested mail action not taken: too much fail …登录失败次数过多,被临时禁止登录。</li><li>553 authentication is required 认证失败【账号密码有可能不对，或者协议配置不对，等等】</li></ul><p>参考地址:<a href="http://help.163.com/09/1224/17/5RAJ4LMHO0753VB8.html%E3%80%90%E5%AE%83%E4%BC%9A%E5%AF%B9%E6%AF%8F%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E8%BF%9B%E8%A1%8C%E8%A7%A3%E9%87%8A%E3%80%91">http://help.163.com/09/1224/17/5RAJ4LMHO0753VB8.html【它会对每一个错误进行解释】</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;记录一下，Spring Boot如何发送邮件。分为以下五种&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发送文本邮件&lt;/li&gt;
&lt;li&gt;发送html邮件&lt;/li&gt;
&lt;li&gt;发送附件邮件&lt;/li&gt;
&lt;li&gt;发送图片邮件&lt;/li&gt;
&lt;li&gt;发送模板邮件&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;配置</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/category/Spring/"/>
    
    
    <category term="发送邮件" scheme="http://example.com/tag/%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot配置文件属性提示消失解决方案</title>
    <link href="http://example.com/post/34ca02aa.html"/>
    <id>http://example.com/post/34ca02aa.html</id>
    <published>2022-08-06T07:42:58.000Z</published>
    <updated>2022-08-06T08:41:33.766Z</updated>
    
    <content type="html"><![CDATA[<img src="\image\article\SpringBoot配置文件属性提示消失解决方案\image-20220806154540571.png" alt="image-20220806154540571" style="zoom: 67%;" /><p>当在SpringBoot中书写配置文件时，没有自动弹提示。</p><p>原因是：SpringBoot在IDEA环境下，提供的功能失效</p><p>解决方案：</p><p>File—-&gt;Project Structure</p><img src="\image\article\SpringBoot配置文件属性提示消失解决方案\image-20220806154818040.png" alt="image-20220806154818040" style="zoom:50%;" /><p>或者：</p><p>右上角的</p><p><img src="/%5Cimage%5Carticle%5CSpringBoot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E6%8F%90%E7%A4%BA%E6%B6%88%E5%A4%B1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%5Cimage-20220806154842981.png" alt="image-20220806154842981"></p><p>点击进入如下界面</p><img src="\image\article\SpringBoot配置文件属性提示消失解决方案\image-20220806154958032.png" alt="image-20220806154958032" style="zoom:80%;" /><img src="\image\article\SpringBoot配置文件属性提示消失解决方案\image-20220806155058176.png" alt="image-20220806155058176" style="zoom:80%;" /><img src="\image/article\SpringBoot配置文件属性提示消失解决方案\image-20220806155138121.png" alt="image-20220806155138121" style="zoom:80%;" /><p>然后一直OK就好。</p><p>然后就可以解决了。</p><p><img src="/%5Cimage%5Carticle%5CSpringBoot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E6%8F%90%E7%A4%BA%E6%B6%88%E5%A4%B1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%5Cimage-20220806155409207.png" alt="image-20220806155409207"></p><p>图标都变了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;\image\article\SpringBoot配置文件属性提示消失解决方案\image-20220806154540571.png&quot; alt=&quot;image-20220806154540571&quot; style=&quot;zoom: 67%;&quot; /&gt;

&lt;p&gt;当在Spr</summary>
      
    
    
    
    <category term="Spring" scheme="http://example.com/category/Spring/"/>
    
    
    <category term="属性提示消失解决方案" scheme="http://example.com/tag/%E5%B1%9E%E6%80%A7%E6%8F%90%E7%A4%BA%E6%B6%88%E5%A4%B1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot读取Yaml配置</title>
    <link href="http://example.com/post/31902768.html"/>
    <id>http://example.com/post/31902768.html</id>
    <published>2022-08-06T07:12:14.000Z</published>
    <updated>2022-08-08T02:43:45.197Z</updated>
    
    <content type="html"><![CDATA[<p>读取配置文件内容三种方式：</p><ul><li>@Value</li><li>Environment</li><li>@ConfigurationProperties</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对象形式</span></span><br><span class="line"><span class="attr">user:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">zhangsan</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">23</span></span><br><span class="line">  <span class="attr">address:</span> <span class="string">xian</span></span><br><span class="line"><span class="comment">#数组格式</span></span><br><span class="line"><span class="attr">object:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">JAVA</span><span class="comment">#- 和 数据用空格分离</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">大数据</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">前端</span></span><br><span class="line"><span class="comment">#字面量  </span></span><br><span class="line"><span class="attr">name:</span> <span class="string">yamiedie</span></span><br></pre></td></tr></table></figure><h1 id="Value方式"><a href="#Value方式" class="headerlink" title="@Value方式"></a>@Value方式</h1><p>需要配置SpEL表达式，<code>$&#123;一级属性名.二级属性名&#125;</code></p><p>​<img src="/%5Cimage%5Carticle%5CSpringBoot%E8%AF%BB%E5%8F%96Yaml%E9%85%8D%E7%BD%AE%5Cimage-20220806160931458.png" alt="image-20220806160931458"></p><ul><li><p>对象形式</p><ul><li>&#96;&#96;&#96;java<br>@Value(“${server.port}”)<br>private int port;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 数组形式</span><br><span class="line"></span><br><span class="line">  - ```java</span><br><span class="line">    @Value(&quot;$&#123;object[1]&#125;&quot;)</span><br><span class="line">    private String object;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>普通形式</p><ul><li>&#96;&#96;&#96;yaml<br>@Value(“${name}”)<br>private String name;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Environment方式</span><br><span class="line"></span><br><span class="line">首先要进行Bean注入</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">@Autowired</span><br><span class="line">private Environment env;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>SpringBoot会通过数据装配的方式把数据全部装到这一个对象里。</p><p>使用<code>getProperty</code>，方法获取属性值。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(env.getProperty(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">System.out.println(env.getProperty(<span class="string">&quot;server.port&quot;</span>));</span><br><span class="line">System.out.println(env.getProperty(<span class="string">&quot;object[1]&quot;</span>));</span><br></pre></td></tr></table></figure><h1 id="ConfigurationProperties方式"><a href="#ConfigurationProperties方式" class="headerlink" title="@ConfigurationProperties方式"></a>@ConfigurationProperties方式</h1><p>使用@ConfigurationProperties注解绑定配置信息到<strong>封装类</strong>中</p><p>例如：</p><p>Yaml配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">datasource:</span></span><br><span class="line">  <span class="attr">driver:</span> <span class="string">com.driver.cj.mysql</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">user:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">me</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">you</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">he</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">she</span></span><br></pre></td></tr></table></figure><p>如果有警告，可以在pom文件中，加入如下依赖。【在classpath中没有发现SpringBoot 配置注解处理器】</p><p><img src="/%5Cimage%5Carticle%5CSpringBoot%E8%AF%BB%E5%8F%96Yaml%E9%85%8D%E7%BD%AE%5Cimage-20220806163710093.png" alt="image-20220806163710093"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>必须加<font color="gold"><strong>@Component</strong></font>注解，注入到Spring容器中。</li><li>prefix属性为一级属性名</li><li>类中必须有Getter和Setter方法，否则无法注入.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;datasource&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mydatasource</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String[] user;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDriver</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> driver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDriver</span><span class="params">(String driver)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.driver = driver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUrl</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUrl</span><span class="params">(String url)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPassword</span><span class="params">(String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] getUser() &#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUser</span><span class="params">(String[] user)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Mydatasource&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;driver=&#x27;&quot;</span> + driver + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, url=&#x27;&quot;</span> + url + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, username=&#x27;&quot;</span> + username + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, password=&#x27;&quot;</span> + password + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">SpringBoot读取Yaml配置的三种方式</summary>
    
    
    
    <category term="Spring" scheme="http://example.com/category/Spring/"/>
    
    
    <category term="Yaml" scheme="http://example.com/tag/Yaml/"/>
    
  </entry>
  
</feed>
